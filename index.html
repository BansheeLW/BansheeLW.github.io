<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="太阳落山了，我是你的渔船，你的锚">
<meta property="og:type" content="website">
<meta property="og:title" content="厦门鱼肝油厂">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="厦门鱼肝油厂">
<meta property="og:description" content="太阳落山了，我是你的渔船，你的锚">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厦门鱼肝油厂">
<meta name="twitter:description" content="太阳落山了，我是你的渔船，你的锚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>厦门鱼肝油厂</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
          <a href="https://github.com/BansheeLW"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厦门鱼肝油厂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/30/longhorn是如何确定哪个longhorn-manager实例才是负责处理资源调谐的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/30/longhorn是如何确定哪个longhorn-manager实例才是负责处理资源调谐的/" itemprop="url">longhorn是如何确定哪个longhorn-manager实例才是负责处理资源调谐的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-30T10:06:34+08:00">
                2021-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="以volume-create-为例"><a href="#以volume-create-为例" class="headerlink" title="以volume create 为例"></a>以volume create 为例</h4><p>volumen 资源创建后，volume Informer watch 到资源变化，volume controller 的worker 开始处理，因为longhorn-manager 实例有多个，也就意味着informer有多个，那么，究竟是哪个manager的informer才是处理某次资源变化的负责人呢？</p>
<h5 id="代码探析："><a href="#代码探析：" class="headerlink" title="代码探析："></a>代码探析：</h5><p>==controller/volume_controller.go==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当前的节点 manager 是否负责运行sync逻辑</span><br><span class="line">isResponsible, err := vc.isResponsibleFor(volume, defaultEngineImage)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line">if !isResponsible &#123;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们查看下 isResponsibleFor 方法的逻辑，代码省略了判错及一些不影响主流程阅读的内容</p>
<p>==controller/volume_controller.go==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// isResponsibleFor picks a running node that has the default engine image deployed.</span><br><span class="line">// We need the default engine image deployed on the node to perform operation like backup operations.</span><br><span class="line">// Prefer picking the node v.Spec.NodeID if it meet the above requirement. 如果满足上述要求，则优先选择节点 v.Spec.NodeID</span><br><span class="line">func (vc *VolumeController) isResponsibleFor(v *longhorn.Volume, defaultEngineImage string) (bool, error) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	isResponsible := isControllerResponsibleFor(vc.controllerID, vc.ds, v.Name, v.Spec.NodeID, v.Status.OwnerID)</span><br><span class="line"></span><br><span class="line">	// No node in the system has the default engine image,</span><br><span class="line">	// Fall back to the default logic where we pick a running node to be the owner</span><br><span class="line">	if len(readyNodesWithDefaultEI) == 0 &#123;</span><br><span class="line">		return isResponsible, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preferredOwnerEngineAvailable, err := vc.ds.CheckEngineImageReadiness(defaultEngineImage, v.Spec.NodeID)</span><br><span class="line"></span><br><span class="line">	currentOwnerEngineAvailable, err := vc.ds.CheckEngineImageReadiness(defaultEngineImage, v.Status.OwnerID)</span><br><span class="line">	</span><br><span class="line">	currentNodeEngineAvailable, err := vc.ds.CheckEngineImageReadiness(defaultEngineImage, vc.controllerID)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	// 如果当前节点engine不可用，那么就不负责处理了</span><br><span class="line">	// 当前节点engine可用 &amp;&amp; （最优、继续、需要新的，都是当前节点）</span><br><span class="line">	isPreferredOwner := currentNodeEngineAvailable &amp;&amp; isResponsible</span><br><span class="line"></span><br><span class="line">	// （当前那节点engine可用 &amp;&amp; 最优节点engine 不可用 &amp;&amp; 当前控制器就是的节点就是之前的owner节点） 继续当前节点</span><br><span class="line">	continueToBeOwner := currentNodeEngineAvailable &amp;&amp; !preferredOwnerEngineAvailable &amp;&amp; vc.controllerID == v.Status.OwnerID</span><br><span class="line"></span><br><span class="line">	// （当前那节点engine可用 &amp;&amp; 最优节点engine 不可用 &amp;&amp; owner节点不engine不可用） 选择当前节点</span><br><span class="line">	requiresNewOwner := currentNodeEngineAvailable &amp;&amp; !preferredOwnerEngineAvailable &amp;&amp; !currentOwnerEngineAvailable</span><br><span class="line"></span><br><span class="line">	return isPreferredOwner || continueToBeOwner || requiresNewOwner, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看下 isControllerResponsibleFor,这个函数是longhorn-manager 资源用来判断当前 manager是否负责处理 sync 逻辑的 通用函数<br>==controller/controller_manager.go==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 挑选指导原则：优先 Spec.NodeId，优先最优节点</span><br><span class="line">func isControllerResponsibleFor(controllerID string, ds *datastore.DataStore, name, preferredOwnerID, currentOwnerID string) bool &#123;</span><br><span class="line">	// we use this approach so that if there is an issue with the data store</span><br><span class="line">	// we don&apos;t accidentally transfer ownership</span><br><span class="line">	isOwnerUnavailable := func(node string) bool &#123;</span><br><span class="line">		isUnavailable, err := ds.IsNodeDownOrDeletedOrMissingManager(node)</span><br><span class="line">		if node != &quot;&quot; &amp;&amp; err != nil &#123;</span><br><span class="line">			logrus.Errorf(&quot;Error while checking IsNodeDownOrDeletedOrMissingManager for object %v, node %v: %v&quot;, name, node, err)</span><br><span class="line">		&#125;</span><br><span class="line">		return node == &quot;&quot; || isUnavailable</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 当前节点是最优节点</span><br><span class="line">	isPreferredOwner := controllerID == preferredOwnerID</span><br><span class="line">	// owner节点是当前节点，且最优节点不可用，那么还是用当前owner节点</span><br><span class="line">	continueToBeOwner := currentOwnerID == controllerID &amp;&amp; isOwnerUnavailable(preferredOwnerID)</span><br><span class="line">	// owner节点不可用，最优节点不可用，需要新节点</span><br><span class="line">	requiresNewOwner := isOwnerUnavailable(currentOwnerID) &amp;&amp; isOwnerUnavailable(preferredOwnerID)</span><br><span class="line">	return isPreferredOwner || continueToBeOwner || requiresNewOwner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>通过以上代码，我们可以总结出：lognhorn-manager 实例主要是判断当前节点是否可负责处理sync逻辑，而判断能否使用当前节点：</p>
<p>最优先条件是当前节点是 perfer(最优节点，perfer的值一般是 xx.Spec.NodeID)</p>
<p>其次是当前节点就是owner节点</p>
<p>最次是最优节点及owner节点都不可用了，那么就使用当前节点</p>
<p>可以看出，节点的挑选最终的优化方向是往 “资源.Spec.NodeId 是哪个，那么就由这个期望的node上的manager来处理”</p>
<p>==注：voulume contoller 这一块加入了 节点engineImage 的判断，与其他资源（例：replica）有些不同，但核心的处理逻辑还是一致的==</p>
<p>（最优不可用，Owner不可用），两个或多个节点都获取到了负责权，这种情况下，是通过 更新 Status.OwnerID，通过 k8s 的版本冲突机制来保证只有最先更新的manager获得处理权，即这一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 这里是 让哪个 vc instance 来处理 volume，如果是volume create，那就是第一个update 的 vc 获取处理权</span><br><span class="line">// 如果只是 volume （update等）其他操作，也是谁先更新谁获得处理权</span><br><span class="line">if volume.Status.OwnerID != vc.controllerID &#123;</span><br><span class="line">	volume.Status.OwnerID = vc.controllerID</span><br><span class="line">	volume, err = vc.ds.UpdateVolumeStatus(volume)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		// we don&apos;t mind others coming first</span><br><span class="line">		if apierrors.IsConflict(errors.Cause(err)) &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	log.Debugf(&quot;Volume got new owner %v&quot;, vc.controllerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/30/longhron磁盘发现机制探索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/30/longhron磁盘发现机制探索/" itemprop="url">longhron磁盘发现机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-30T10:02:13+08:00">
                2021-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>longhorn 的crd nodes.longhorn.io 里是有存储disk信息的，这个node自定义资源的创建是在 longhorn-manager Daemon 启动时initDaemonNode</p>
<p>datastore/longhorn.go:CreateDefaultNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// For newly added node, the customized default disks will be applied only if the setting is enabled.</span><br><span class="line">if !requireLabel &#123;</span><br><span class="line">	// Note: this part wasn&apos;t moved to the controller is because</span><br><span class="line">	// this will be done only once.</span><br><span class="line">	// If user remove all the disks on the node, the default disk</span><br><span class="line">	// will not be recreated automatically</span><br><span class="line">	dataPath, err := s.GetSettingValueExisted(types.SettingNameDefaultDataPath)</span><br><span class="line">	// dataPath : 默认是/var/lib/longhorn/,从settings crd中获取</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	disks, err := types.CreateDefaultDisk(dataPath)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	node.Spec.Disks = disks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建默认disk 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func CreateDefaultDisk(dataPath string) (map[string]DiskSpec, error) &#123;</span><br><span class="line">	if err := util.CreateDiskPathReplicaSubdirectory(dataPath); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	diskInfo, err := util.GetDiskInfo(dataPath)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return map[string]DiskSpec&#123;</span><br><span class="line">		DefaultDiskPrefix + diskInfo.Fsid: &#123;</span><br><span class="line">			Path:              diskInfo.Path,</span><br><span class="line">			AllowScheduling:   true,</span><br><span class="line">			EvictionRequested: false,</span><br><span class="line">			StorageReserved:   diskInfo.StorageMaximum * 30 / 100, // 磁盘预留空间，也即是我们在longhorn Dashboard Node.Size 看到的 Reserved 值</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CreateDiskPathReplicaSubdirectory 这个函数只是创建 replicas 子目录，而核心逻辑是GetDiskInfo获取disk信息，那么接下来我们就看下具体代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func GetDiskInfo(directory string) (info *DiskInfo, err error) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		err = errors.Wrapf(err, &quot;cannot get disk info of directory %v&quot;, directory)</span><br><span class="line">	&#125;()</span><br><span class="line">	initiatorNSPath := iscsi_util.GetHostNamespacePath(HostProcPath)</span><br><span class="line">	mountPath := fmt.Sprintf(&quot;--mount=%s/mnt&quot;, initiatorNSPath)</span><br><span class="line">	// mountPath: /host/proc/pid/ns/</span><br><span class="line">	// stat -f -c &quot;&#123;\&quot;path\&quot;:\&quot;%n\&quot;,\&quot;fsid\&quot;:\&quot;%i\&quot;,\&quot;type\&quot;:\&quot;%T\&quot;,\&quot;freeBlock\&quot;:%f,\&quot;totalBlock\&quot;:%b,\&quot;blockSize\&quot;:%S&#125;&quot; /var/lib/longhorn/</span><br><span class="line">	// nsenter --mount=/host/proc/pid/ns/mnt command(stat -fc ...)</span><br><span class="line">	output, err := Execute([]string&#123;&#125;, &quot;nsenter&quot;, mountPath, &quot;stat&quot;, &quot;-fc&quot;, &quot;&#123;\&quot;path\&quot;:\&quot;%n\&quot;,\&quot;fsid\&quot;:\&quot;%i\&quot;,\&quot;type\&quot;:\&quot;%T\&quot;,\&quot;freeBlock\&quot;:%f,\&quot;totalBlock\&quot;:%b,\&quot;blockSize\&quot;:%S&#125;&quot;, directory)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	output = strings.Replace(output, &quot;\n&quot;, &quot;&quot;, -1)</span><br><span class="line"></span><br><span class="line">	diskInfo := &amp;DiskInfo&#123;&#125;</span><br><span class="line">	err = json.Unmarshal([]byte(output), diskInfo)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	diskInfo.StorageMaximum = diskInfo.TotalBlock * diskInfo.BlockSize</span><br><span class="line">	diskInfo.StorageAvailable = diskInfo.FreeBlock * diskInfo.BlockSize</span><br><span class="line"></span><br><span class="line">	return diskInfo, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，核心就是用了 linux 的nsenter命令，以及用 stat 命令获取 文件系统信息，最后反序列化转换成自定义disk结构体</p>
<p>附录：<br>neenter 命令：<a href="https://staight.github.io/2019/09/23/nsenter%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">https://staight.github.io/2019/09/23/nsenter%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/grpc-go 服务端接收请求响应源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/grpc-go 服务端接收请求响应源码分析/" itemprop="url">grpc-go 服务端接收请求响应源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T23:47:25+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>服务端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type TigerServer struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (t *TigerServer) HelloTiger(ctx context.Context,req *server_hello_proto.HelloRequest) ( *server_hello_proto.HelloResponse,  error) &#123;</span><br><span class="line">	resp := &amp;server_hello_proto.HelloResponse&#123;&#125;</span><br><span class="line">	resp.Name = req.Name</span><br><span class="line">	resp.Age = req.Age + 11</span><br><span class="line">	return resp,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	server_hello_proto.RegisterTigerServiceServer(grpcServer,new(TigerServer))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:1235&quot;)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码可以看出，开启一个gRPC服务的代码非常简洁</p>
<ol>
<li>实例化一个grpc.Server</li>
<li>将实现了pb文件中service接口的服务对象注册进grpc.Server</li>
<li>监听端口</li>
<li>接收连接请求</li>
</ol>
<h3 id="实例化server"><a href="#实例化server" class="headerlink" title="实例化server"></a>实例化server</h3><p>首先我们来看实例化一个server做了些什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// NewServer creates a gRPC server which has no service registered and has not</span><br><span class="line">// started to accept requests yet.</span><br><span class="line">func NewServer(opt ...ServerOption) *Server &#123;</span><br><span class="line">	opts := defaultServerOptions</span><br><span class="line">	for _, o := range opt &#123;</span><br><span class="line">		o.apply(&amp;opts)</span><br><span class="line">	&#125;</span><br><span class="line">	s := &amp;Server&#123;</span><br><span class="line">		lis:    make(map[net.Listener]bool),</span><br><span class="line">		opts:   opts,</span><br><span class="line">		conns:  make(map[transport.ServerTransport]bool),</span><br><span class="line">		m:      make(map[string]*service),</span><br><span class="line">		quit:   grpcsync.NewEvent(),</span><br><span class="line">		done:   grpcsync.NewEvent(),</span><br><span class="line">		czData: new(channelzData),</span><br><span class="line">	&#125;</span><br><span class="line">	chainUnaryServerInterceptors(s)</span><br><span class="line">	chainStreamServerInterceptors(s)</span><br><span class="line">	s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">	if EnableTracing &#123;</span><br><span class="line">		_, file, line, _ := runtime.Caller(1)</span><br><span class="line">		s.events = trace.NewEventLog(&quot;grpc.Server&quot;, fmt.Sprintf(&quot;%s:%d&quot;, file, line))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		s.channelzID = channelz.RegisterServer(&amp;channelzServer&#123;s&#125;, &quot;&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这个函数与客户端Dial的处理流程很相似，都是接收一个可变参数用于覆盖默认配置，然后是初始化grpc.Server结构体，拦截器相关处理及一些grpc调用监控相关的初始化处理。</p>
<p>这里最关键的就是初始化grpc.Server结构体了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">	opts serverOptions //服务端可选配置项</span><br><span class="line"></span><br><span class="line">	mu     sync.Mutex // guards following</span><br><span class="line">	lis    map[net.Listener]bool //监听地址列表</span><br><span class="line">	conns  map[transport.ServerTransport]bool //连接列表</span><br><span class="line">	serve  bool</span><br><span class="line">	drain  bool</span><br><span class="line">	cv     *sync.Cond          // signaled when connections close for GracefulStop</span><br><span class="line">	m      map[string]*service // service name -&gt; service info //一个映射，通过service对象名找到这个service对象的信息</span><br><span class="line">	events trace.EventLog</span><br><span class="line"></span><br><span class="line">	quit               *grpcsync.Event</span><br><span class="line">	done               *grpcsync.Event</span><br><span class="line">	channelzRemoveOnce sync.Once</span><br><span class="line">	serveWG            sync.WaitGroup // counts active Serve goroutines for GracefulStop</span><br><span class="line"></span><br><span class="line">	channelzID int64 // channelz unique identification number</span><br><span class="line">	czData     *channelzData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端可选配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type serverOptions struct &#123;</span><br><span class="line">	creds                 credentials.TransportCredentials    //加密证书相关（TLS)</span><br><span class="line">	codec                 baseCodec //序列化，如protobuf</span><br><span class="line">	cp                    Compressor //压缩 gzip</span><br><span class="line">	dc                    Decompressor //解压缩 gzip</span><br><span class="line">	unaryInt              UnaryServerInterceptor //单次拦截器</span><br><span class="line">	streamInt             StreamServerInterceptor //流式拦截器</span><br><span class="line">	chainUnaryInts        []UnaryServerInterceptor</span><br><span class="line">	chainStreamInts       []StreamServerInterceptor</span><br><span class="line">	inTapHandle           tap.ServerInHandle</span><br><span class="line">	statsHandler          stats.Handler</span><br><span class="line">	//HTTP2 协议相关规范</span><br><span class="line">	maxConcurrentStreams  uint32</span><br><span class="line">	maxReceiveMessageSize int</span><br><span class="line">	maxSendMessageSize    int</span><br><span class="line">	unknownStreamDesc     *StreamDesc</span><br><span class="line">	//长连接保活相关，客户端会专门起一个goroutine去处理长连接事宜</span><br><span class="line">	keepaliveParams       keepalive.ServerParameters</span><br><span class="line">	keepalivePolicy       keepalive.EnforcementPolicy</span><br><span class="line">	initialWindowSize     int32</span><br><span class="line">	initialConnWindowSize int32</span><br><span class="line">	writeBufferSize       int</span><br><span class="line">	readBufferSize        int</span><br><span class="line">	connectionTimeout     time.Duration</span><br><span class="line">	maxHeaderListSize     *uint32</span><br><span class="line">	headerTableSize       *uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="将注册服务对象注册进server"><a href="#将注册服务对象注册进server" class="headerlink" title="将注册服务对象注册进server"></a>将注册服务对象注册进server</h3><p>将服务对象注册进server的函数是pb文件中用protoc代码生成插件protoc-gen-go工具自动生成的。</p>
<p>pb文件中服务端相关代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 服务描述</span><br><span class="line">var _TigerService_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">	ServiceName: &quot;server_hello_proto.TigerService&quot;, //服务名</span><br><span class="line">	HandlerType: (*TigerServiceServer)(nil), //这里申明了该服务需要实现的接口</span><br><span class="line">	Methods: []grpc.MethodDesc&#123; //服务方法描述</span><br><span class="line">		&#123;</span><br><span class="line">			MethodName: &quot;HelloTiger&quot;, //rpc方法名</span><br><span class="line">			Handler:    _TigerService_HelloTiger_Handler,//rpc请求的handler</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			MethodName: &quot;FeedTiger&quot;,</span><br><span class="line">			Handler:    _TigerService_FeedTiger_Handler,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	Streams: []grpc.StreamDesc&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			StreamName:    &quot;Channel&quot;,</span><br><span class="line">			Handler:       _TigerService_Channel_Handler,</span><br><span class="line">			ServerStreams: true,</span><br><span class="line">			ClientStreams: true,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	Metadata: &quot;hello.proto&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterTigerServiceServer(s *grpc.Server, srv TigerServiceServer) &#123;</span><br><span class="line">        //传入服务描述及具体的服务实现对象</span><br><span class="line">	s.RegisterService(&amp;_TigerService_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下代码可以看出，实际上还是调用grpc包中的注册方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// RegisterService registers a service and its implementation to the gRPC</span><br><span class="line">// server. It is called from the IDL generated code. This must be called before</span><br><span class="line">// invoking Serve.</span><br><span class="line">// 这个方法由IDL（也就是protobuf）通过插件生成的代码调用。这个调用必须要在Server开始接受请求之前调用</span><br><span class="line">//这段代码主要是判断具体服务是否实现了服务接口</span><br><span class="line">func (s *Server) RegisterService(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	ht := reflect.TypeOf(sd.HandlerType).Elem()</span><br><span class="line">	st := reflect.TypeOf(ss)</span><br><span class="line">	if !st.Implements(ht) &#123;</span><br><span class="line">		grpclog.Fatalf(&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;, st, ht)</span><br><span class="line">	&#125;</span><br><span class="line">	s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Server) register(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	defer s.mu.Unlock()</span><br><span class="line">	s.printf(&quot;RegisterService(%q)&quot;, sd.ServiceName)</span><br><span class="line">	//如果server已经运行了，不允许注册</span><br><span class="line">	if s.serve &#123;</span><br><span class="line">		grpclog.Fatalf(&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	//不允许注册相同名字的服务</span><br><span class="line">	if _, ok := s.m[sd.ServiceName]; ok &#123;</span><br><span class="line">		grpclog.Fatalf(&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	srv := &amp;service&#123;</span><br><span class="line">		server: ss,</span><br><span class="line">		md:     make(map[string]*MethodDesc),</span><br><span class="line">		sd:     make(map[string]*StreamDesc),</span><br><span class="line">		mdata:  sd.Metadata,</span><br><span class="line">	&#125;</span><br><span class="line">	for i := range sd.Methods &#123;</span><br><span class="line">		d := &amp;sd.Methods[i]</span><br><span class="line">		srv.md[d.MethodName] = d</span><br><span class="line">	&#125;</span><br><span class="line">	for i := range sd.Streams &#123;</span><br><span class="line">		d := &amp;sd.Streams[i]</span><br><span class="line">		srv.sd[d.StreamName] = d</span><br><span class="line">	&#125;</span><br><span class="line">	s.m[sd.ServiceName] = srv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，register主要是将服务名和具体服务信息添加进Server的属性映射m，也就是服务名与具体服务信息的映射，相当于是http web中的路由表。</p>
<h3 id="server开始监听并接收请求"><a href="#server开始监听并接收请求" class="headerlink" title="server开始监听并接收请求"></a>server开始监听并接收请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">// Serve accepts incoming connections on the listener lis, creating a new</span><br><span class="line">// ServerTransport and service goroutine for each. The service goroutines</span><br><span class="line">// read gRPC requests and then call the registered handlers to reply to them.</span><br><span class="line">// Serve returns when lis.Accept fails with fatal errors.  lis will be closed when</span><br><span class="line">// this method returns.</span><br><span class="line">// Serve will return a non-nil error unless Stop or GracefulStop is called.</span><br><span class="line">func (s *Server) Serve(lis net.Listener) error &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.printf(&quot;serving&quot;)</span><br><span class="line">	//置为true，则标志着Server真正开始运行</span><br><span class="line">	s.serve = true</span><br><span class="line">	if s.lis == nil &#123;</span><br><span class="line">		// Serve called after Stop or GracefulStop.</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		lis.Close()</span><br><span class="line">		return ErrServerStopped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.serveWG.Add(1)</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		s.serveWG.Done()</span><br><span class="line">		if s.quit.HasFired() &#123;</span><br><span class="line">			// Stop or GracefulStop called; block until done and return nil.</span><br><span class="line">			&lt;-s.done.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    //一个Server可以监听多个端口</span><br><span class="line">	ls := &amp;listenSocket&#123;Listener: lis&#125;</span><br><span class="line">	s.lis[ls] = true</span><br><span class="line"></span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		ls.channelzID = channelz.RegisterListenSocket(ls, s.channelzID, lis.Addr().String())</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    //退出时，将lis映射中的ls监听删除</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		if s.lis != nil &amp;&amp; s.lis[ls] &#123;</span><br><span class="line">			ls.Close()</span><br><span class="line">			delete(s.lis, ls)</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var tempDelay time.Duration // how long to sleep on accept failure</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		rawConn, err := lis.Accept()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			if ne, ok := err.(interface &#123;</span><br><span class="line">				Temporary() bool</span><br><span class="line">			&#125;); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				if tempDelay == 0 &#123;</span><br><span class="line">					tempDelay = 5 * time.Millisecond</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					tempDelay *= 2</span><br><span class="line">				&#125;</span><br><span class="line">				if max := 1 * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				s.mu.Lock()</span><br><span class="line">				s.printf(&quot;Accept error: %v; retrying in %v&quot;, err, tempDelay)</span><br><span class="line">				s.mu.Unlock()</span><br><span class="line">				timer := time.NewTimer(tempDelay)</span><br><span class="line">				select &#123;</span><br><span class="line">				case &lt;-timer.C:</span><br><span class="line">				case &lt;-s.quit.Done():</span><br><span class="line">					timer.Stop()</span><br><span class="line">					return nil</span><br><span class="line">				&#125;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			s.mu.Lock()</span><br><span class="line">			s.printf(&quot;done serving; Accept = %v&quot;, err)</span><br><span class="line">			s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">			if s.quit.HasFired() &#123;</span><br><span class="line">				return nil</span><br><span class="line">			&#125;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = 0</span><br><span class="line">		// Start a new goroutine to deal with rawConn so we don&apos;t stall this Accept</span><br><span class="line">		// loop goroutine.</span><br><span class="line">		//</span><br><span class="line">		// Make sure we account for the goroutine so GracefulStop doesn&apos;t nil out</span><br><span class="line">		// s.conns before this conn can be added.</span><br><span class="line">		s.serveWG.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			s.handleRawConn(rawConn)</span><br><span class="line">			s.serveWG.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，每个请求进来，Server会起一个goroutine去处理这个请求，真正处理客户端请求的是 handleRawConn 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// handleRawConn forks a goroutine to handle a just-accepted connection that</span><br><span class="line">// has not had any I/O performed on it yet.</span><br><span class="line">func (s *Server) handleRawConn(rawConn net.Conn) &#123;</span><br><span class="line">	if s.quit.HasFired() &#123;</span><br><span class="line">		rawConn.Close()</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 设置 read和 write的Deadline</span><br><span class="line">	rawConn.SetDeadline(time.Now().Add(s.opts.connectionTimeout))</span><br><span class="line">	//如果有配置TLS证书之类的，要进行TLS握手相关操作</span><br><span class="line">	conn, authInfo, err := s.useTransportAuthenticator(rawConn)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		// ErrConnDispatched means that the connection was dispatched away from</span><br><span class="line">		// gRPC; those connections should be left open.</span><br><span class="line">		if err != credentials.ErrConnDispatched &#123;</span><br><span class="line">			s.mu.Lock()</span><br><span class="line">			s.errorf(&quot;ServerHandshake(%q) failed: %v&quot;, rawConn.RemoteAddr(), err)</span><br><span class="line">			s.mu.Unlock()</span><br><span class="line">			channelz.Warningf(s.channelzID, &quot;grpc: Server.Serve failed to complete security handshake from %q: %v&quot;, rawConn.RemoteAddr(), err)</span><br><span class="line">			rawConn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		rawConn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //完成HTTP2握手（处理http2连接的建立，http2连接的建立也需要客户端和服务端交换，即http2 Connection Preface）</span><br><span class="line">    //将客户端HTTP2请求连接转换为 http2协议类型的transport.ServerTransport,也就是http2Server</span><br><span class="line">	// Finish handshaking (HTTP2)</span><br><span class="line">	st := s.newHTTP2Transport(conn, authInfo)</span><br><span class="line">	if st == nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //将链接的deadline置为空，因为这时握手已经完成了，而客户端并不是一直都在发送请求的</span><br><span class="line">	rawConn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">	//将HTTP2连接添加进Server的HTTP2链接映射</span><br><span class="line">	if !s.addConn(st) &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	go func() &#123;</span><br><span class="line">	    //等待rpc请求到来，处理请求</span><br><span class="line">		s.serveStreams(st)</span><br><span class="line">		//移除http2连接</span><br><span class="line">		s.removeConn(st)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 每个http2连接在服务端会生成一个ServerTransport，这里是 htt2server</span><br><span class="line">// newHTTP2Transport sets up a http/2 transport (using the</span><br><span class="line">// gRPC http2 server transport in transport/http2_server.go).</span><br><span class="line">func (s *Server) newHTTP2Transport(c net.Conn, authInfo credentials.AuthInfo) transport.ServerTransport &#123;</span><br><span class="line">	config := &amp;transport.ServerConfig&#123;</span><br><span class="line">		MaxStreams:            s.opts.maxConcurrentStreams,</span><br><span class="line">		AuthInfo:              authInfo,</span><br><span class="line">		InTapHandle:           s.opts.inTapHandle,</span><br><span class="line">		StatsHandler:          s.opts.statsHandler,</span><br><span class="line">		KeepaliveParams:       s.opts.keepaliveParams,</span><br><span class="line">		KeepalivePolicy:       s.opts.keepalivePolicy,</span><br><span class="line">		InitialWindowSize:     s.opts.initialWindowSize,</span><br><span class="line">		InitialConnWindowSize: s.opts.initialConnWindowSize,</span><br><span class="line">		WriteBufferSize:       s.opts.writeBufferSize,</span><br><span class="line">		ReadBufferSize:        s.opts.readBufferSize,</span><br><span class="line">		ChannelzParentID:      s.channelzID,</span><br><span class="line">		MaxHeaderListSize:     s.opts.maxHeaderListSize,</span><br><span class="line">		HeaderTableSize:       s.opts.headerTableSize,</span><br><span class="line">	&#125;</span><br><span class="line">	//返回了实现了ServerTransport接口的http2Server</span><br><span class="line">	//ServerTransport接口规定了HandleStreams、WriteHeader 等方法</span><br><span class="line">	st, err := transport.NewServerTransport(&quot;http2&quot;, c, config)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		s.errorf(&quot;NewServerTransport(%q) failed: %v&quot;, c.RemoteAddr(), err)</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		c.Close()</span><br><span class="line">		channelz.Warning(s.channelzID, &quot;grpc: Server.Serve failed to create ServerTransport: &quot;, err)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return st</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NewServerTransport creates a ServerTransport with conn or non-nil error</span><br><span class="line">// if it fails.</span><br><span class="line">func NewServerTransport(protocol string, conn net.Conn, config *ServerConfig) (ServerTransport, error) &#123;</span><br><span class="line">	return newHTTP2Server(conn, config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">// newHTTP2Server constructs a ServerTransport based on HTTP2. ConnectionError is</span><br><span class="line">// returned if something goes wrong.</span><br><span class="line">func newHTTP2Server(conn net.Conn, config *ServerConfig) (_ ServerTransport, err error) &#123;</span><br><span class="line">    //初始化一些读写缓冲长度的限制</span><br><span class="line">	writeBufSize := config.WriteBufferSize</span><br><span class="line">	readBufSize := config.ReadBufferSize</span><br><span class="line">	maxHeaderListSize := defaultServerMaxHeaderListSize</span><br><span class="line">	if config.MaxHeaderListSize != nil &#123;</span><br><span class="line">		maxHeaderListSize = *config.MaxHeaderListSize</span><br><span class="line">	&#125;</span><br><span class="line">	//封装帧的读取，底层用的是http2.frame</span><br><span class="line">	framer := newFramer(conn, writeBufSize, readBufSize, maxHeaderListSize)</span><br><span class="line">	// Send initial settings as connection preface to client.</span><br><span class="line">	//初始化配置帧（HTTP2连接前奏）</span><br><span class="line">	isettings := []http2.Setting&#123;&#123;</span><br><span class="line">		ID:  http2.SettingMaxFrameSize,</span><br><span class="line">		Val: http2MaxFrameLen,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">	// TODO(zhaoq): Have a better way to signal &quot;no limit&quot; because 0 is</span><br><span class="line">	// permitted in the HTTP2 spec.</span><br><span class="line">	// 流的最大数量</span><br><span class="line">	maxStreams := config.MaxStreams</span><br><span class="line">	if maxStreams == 0 &#123;</span><br><span class="line">		maxStreams = math.MaxUint32</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		isettings = append(isettings, http2.Setting&#123;</span><br><span class="line">			ID:  http2.SettingMaxConcurrentStreams,</span><br><span class="line">			Val: maxStreams,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	dynamicWindow := true</span><br><span class="line">	iwz := int32(initialWindowSize)</span><br><span class="line">	if config.InitialWindowSize &gt;= defaultWindowSize &#123;</span><br><span class="line">		iwz = config.InitialWindowSize</span><br><span class="line">		dynamicWindow = false</span><br><span class="line">	&#125;</span><br><span class="line">	icwz := int32(initialWindowSize)</span><br><span class="line">	if config.InitialConnWindowSize &gt;= defaultWindowSize &#123;</span><br><span class="line">		icwz = config.InitialConnWindowSize</span><br><span class="line">		dynamicWindow = false</span><br><span class="line">	&#125;</span><br><span class="line">	if iwz != defaultWindowSize &#123;</span><br><span class="line">		isettings = append(isettings, http2.Setting&#123;</span><br><span class="line">			ID:  http2.SettingInitialWindowSize,</span><br><span class="line">			Val: uint32(iwz)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	if config.MaxHeaderListSize != nil &#123;</span><br><span class="line">		isettings = append(isettings, http2.Setting&#123;</span><br><span class="line">			ID:  http2.SettingMaxHeaderListSize,</span><br><span class="line">			Val: *config.MaxHeaderListSize,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	if config.HeaderTableSize != nil &#123;</span><br><span class="line">		isettings = append(isettings, http2.Setting&#123;</span><br><span class="line">			ID:  http2.SettingHeaderTableSize,</span><br><span class="line">			Val: *config.HeaderTableSize,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	if err := framer.fr.WriteSettings(isettings...); err != nil &#123;</span><br><span class="line">		return nil, connectionErrorf(false, err, &quot;transport: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	// Adjust the connection flow control window if needed.</span><br><span class="line">	if delta := uint32(icwz - defaultWindowSize); delta &gt; 0 &#123;</span><br><span class="line">		if err := framer.fr.WriteWindowUpdate(0, delta); err != nil &#123;</span><br><span class="line">			return nil, connectionErrorf(false, err, &quot;transport: %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// tcp连接的KeepAlive相关参数</span><br><span class="line">	kp := config.KeepaliveParams</span><br><span class="line">	if kp.MaxConnectionIdle == 0 &#123;</span><br><span class="line">		kp.MaxConnectionIdle = defaultMaxConnectionIdle</span><br><span class="line">	&#125;</span><br><span class="line">	if kp.MaxConnectionAge == 0 &#123;</span><br><span class="line">		kp.MaxConnectionAge = defaultMaxConnectionAge</span><br><span class="line">	&#125;</span><br><span class="line">	// Add a jitter to MaxConnectionAge.</span><br><span class="line">	kp.MaxConnectionAge += getJitter(kp.MaxConnectionAge)</span><br><span class="line">	if kp.MaxConnectionAgeGrace == 0 &#123;</span><br><span class="line">		kp.MaxConnectionAgeGrace = defaultMaxConnectionAgeGrace</span><br><span class="line">	&#125;</span><br><span class="line">	// 最大idle时间，超过此客户端连接将被关闭，默认无穷</span><br><span class="line">	if kp.Time == 0 &#123;</span><br><span class="line">		kp.Time = defaultServerKeepaliveTime</span><br><span class="line">	&#125;</span><br><span class="line">	if kp.Timeout == 0 &#123;</span><br><span class="line">		kp.Timeout = defaultServerKeepaliveTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	kep := config.KeepalivePolicy</span><br><span class="line">	if kep.MinTime == 0 &#123;</span><br><span class="line">		kep.MinTime = defaultKeepalivePolicyMinTime</span><br><span class="line">	&#125;</span><br><span class="line">	done := make(chan struct&#123;&#125;)</span><br><span class="line">	t := &amp;http2Server&#123;</span><br><span class="line">		ctx:               context.Background(),</span><br><span class="line">		done:              done,</span><br><span class="line">		conn:              conn,</span><br><span class="line">		remoteAddr:        conn.RemoteAddr(),</span><br><span class="line">		localAddr:         conn.LocalAddr(),</span><br><span class="line">		authInfo:          config.AuthInfo,</span><br><span class="line">		framer:            framer,</span><br><span class="line">		readerDone:        make(chan struct&#123;&#125;),</span><br><span class="line">		writerDone:        make(chan struct&#123;&#125;),</span><br><span class="line">		maxStreams:        maxStreams,</span><br><span class="line">		inTapHandle:       config.InTapHandle,</span><br><span class="line">		fc:                &amp;trInFlow&#123;limit: uint32(icwz)&#125;,</span><br><span class="line">		state:             reachable,</span><br><span class="line">		activeStreams:     make(map[uint32]*Stream),</span><br><span class="line">		stats:             config.StatsHandler,</span><br><span class="line">		kp:                kp,</span><br><span class="line">		idle:              time.Now(),</span><br><span class="line">		kep:               kep,</span><br><span class="line">		initialWindowSize: iwz,</span><br><span class="line">		czData:            new(channelzData),</span><br><span class="line">		bufferPool:        newBufferPool(),</span><br><span class="line">	&#125;</span><br><span class="line">	t.controlBuf = newControlBuffer(t.done)</span><br><span class="line">	if dynamicWindow &#123;</span><br><span class="line">		t.bdpEst = &amp;bdpEstimator&#123;</span><br><span class="line">			bdp:               initialWindowSize,</span><br><span class="line">			updateFlowControl: t.updateFlowControl,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if t.stats != nil &#123;</span><br><span class="line">		t.ctx = t.stats.TagConn(t.ctx, &amp;stats.ConnTagInfo&#123;</span><br><span class="line">			RemoteAddr: t.remoteAddr,</span><br><span class="line">			LocalAddr:  t.localAddr,</span><br><span class="line">		&#125;)</span><br><span class="line">		connBegin := &amp;stats.ConnBegin&#123;&#125;</span><br><span class="line">		t.stats.HandleConn(t.ctx, connBegin)</span><br><span class="line">	&#125;</span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		t.channelzID = channelz.RegisterNormalSocket(t, config.ChannelzParentID, fmt.Sprintf(&quot;%s -&gt; %s&quot;, t.remoteAddr, t.localAddr))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.connectionID = atomic.AddUint64(&amp;serverConnectionCounter, 1)</span><br><span class="line"></span><br><span class="line">	t.framer.writer.Flush()</span><br><span class="line"></span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			t.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    // 校验客户端http2建立前奏的perface是否有效</span><br><span class="line">	// Check the validity of client preface.</span><br><span class="line">	preface := make([]byte, len(clientPreface))</span><br><span class="line">	if _, err := io.ReadFull(t.conn, preface); err != nil &#123;</span><br><span class="line">		return nil, connectionErrorf(false, err, &quot;transport: http2Server.HandleStreams failed to receive the preface from client: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if !bytes.Equal(preface, clientPreface) &#123;</span><br><span class="line">		return nil, connectionErrorf(false, nil, &quot;transport: http2Server.HandleStreams received bogus greeting from client: %q&quot;, preface)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	frame, err := t.framer.fr.ReadFrame()</span><br><span class="line">	if err == io.EOF || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, connectionErrorf(false, err, &quot;transport: http2Server.HandleStreams failed to read initial settings frame: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.StoreInt64(&amp;t.lastRead, time.Now().UnixNano())</span><br><span class="line">	sf, ok := frame.(*http2.SettingsFrame)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return nil, connectionErrorf(false, nil, &quot;transport: http2Server.HandleStreams saw invalid preface type %T from client&quot;, frame)</span><br><span class="line">	&#125;</span><br><span class="line">	t.handleSettings(sf)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		t.loopy = newLoopyWriter(serverSide, t.framer, t.controlBuf, t.bdpEst)</span><br><span class="line">		t.loopy.ssGoAwayHandler = t.outgoingGoAwayHandler</span><br><span class="line">		if err := t.loopy.run(); err != nil &#123;</span><br><span class="line">			errorf(&quot;transport: loopyWriter.run returning. Err: %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		t.conn.Close()</span><br><span class="line">		close(t.writerDone)</span><br><span class="line">	&#125;()</span><br><span class="line">	//起一个goroutine专门处理tcp保活</span><br><span class="line">	go t.keepalive()</span><br><span class="line">	return t, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个HTTP2请求进来，先HTT2协议握手建立HTT2连接（处理建立连接过程中的帧数据），然后一直循环处理新的流的建立（新的HTTP2请求到来）和数据帧的收发（基于HTTP2的多路复用，客户端可以使用同一条链接同时发送多个请求）。HTTP2链接在代码层面为ServerTransport，也就是http2Server</p>
<p>接下来我们看下serveStreams方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) serveStreams(st transport.ServerTransport) &#123;</span><br><span class="line">	defer st.Close()</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	st.HandleStreams(func(stream *transport.Stream) &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		//回调中开启子goroutine，处理rpc请求</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			//grpc基于http2，一个rpc请求使用一个stream，一个连接可能有多个rpc请求，也就存在多个请求stream过来</span><br><span class="line">			//当有新的rpc请求进来，就会进入此回调，然后调用server的handleStream方法处理rpc请求</span><br><span class="line">			s.handleStream(st, stream, s.traceInfo(st, stream))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;, func(ctx context.Context, method string) context.Context &#123;</span><br><span class="line">		if !EnableTracing &#123;</span><br><span class="line">			return ctx</span><br><span class="line">		&#125;</span><br><span class="line">		tr := trace.New(&quot;grpc.Recv.&quot;+methodFamily(method), method)</span><br><span class="line">		return trace.NewContext(ctx, tr)</span><br><span class="line">	&#125;)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这里是使用waitGroup进行阻塞等待，不断处理同一个http2连接的请求。</p>
<p>HandleStreams使用注册的Handler处理请求streams<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandleStreams(func(*Stream), func(context.Context, string) context.Context)</span><br></pre></td></tr></table></figure></p>
<p>这是一个接口方法，这里的具体实现是http2Server的HandleStreams方法，传入一个处理stream的handler处理函数，一个trace处理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) &#123;</span><br><span class="line">	defer close(t.readerDone)</span><br><span class="line">	for &#123;</span><br><span class="line">		t.controlBuf.throttle()</span><br><span class="line">		frame, err := t.framer.fr.ReadFrame()</span><br><span class="line">		atomic.StoreInt64(&amp;t.lastRead, time.Now().UnixNano())</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			if se, ok := err.(http2.StreamError); ok &#123;</span><br><span class="line">				warningf(&quot;transport: http2Server.HandleStreams encountered http2.StreamError: %v&quot;, se)</span><br><span class="line">				t.mu.Lock()</span><br><span class="line">				s := t.activeStreams[se.StreamID]</span><br><span class="line">				t.mu.Unlock()</span><br><span class="line">				if s != nil &#123;</span><br><span class="line">					t.closeStream(s, true, se.Code, false)</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					t.controlBuf.put(&amp;cleanupStream&#123;</span><br><span class="line">						streamID: se.StreamID,</span><br><span class="line">						rst:      true,</span><br><span class="line">						rstCode:  se.Code,</span><br><span class="line">						onWrite:  func() &#123;&#125;,</span><br><span class="line">					&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			if err == io.EOF || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			warningf(&quot;transport: http2Server.HandleStreams failed to read frame: %v&quot;, err)</span><br><span class="line">			t.Close()</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		switch frame := frame.(type) &#123;</span><br><span class="line">		case *http2.MetaHeadersFrame:</span><br><span class="line">			if t.operateHeaders(frame, handle, traceCtx) &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		case *http2.DataFrame:</span><br><span class="line">			t.handleData(frame)</span><br><span class="line">		case *http2.RSTStreamFrame:</span><br><span class="line">			t.handleRSTStream(frame)</span><br><span class="line">		case *http2.SettingsFrame:</span><br><span class="line">			t.handleSettings(frame)</span><br><span class="line">		case *http2.PingFrame:</span><br><span class="line">			t.handlePing(frame)</span><br><span class="line">		case *http2.WindowUpdateFrame:</span><br><span class="line">			t.handleWindowUpdate(frame)</span><br><span class="line">		case *http2.GoAwayFrame:</span><br><span class="line">			// TODO: Handle GoAway from the client appropriately.</span><br><span class="line">		default:</span><br><span class="line">			errorf(&quot;transport: http2Server.HandleStreams found unhandled frame type %v.&quot;, frame)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出该方法循环读取客户端连接发送过来的帧，如果是HEADER帧，说明有新的rpc请求进来，回调handler;如果是DATA帧，将数据分发到stream;如果是RST帧…</p>
<p>接着我们来看下server的handleStream方法，该方法处理新的rpc请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) &#123;</span><br><span class="line">    //下面的这段代码主要是分割字符串取出service服务名与相应的方法名</span><br><span class="line">	sm := stream.Method()</span><br><span class="line">	//去除开头的&apos;/&apos;</span><br><span class="line">	if sm != &quot;&quot; &amp;&amp; sm[0] == &apos;/&apos; &#123;</span><br><span class="line">		sm = sm[1:]</span><br><span class="line">	&#125;</span><br><span class="line">	pos := strings.LastIndex(sm, &quot;/&quot;)</span><br><span class="line">	if pos == -1 &#123;</span><br><span class="line">		if trInfo != nil &#123;</span><br><span class="line">			trInfo.tr.LazyLog(&amp;fmtStringer&#123;&quot;Malformed method name %q&quot;, []interface&#123;&#125;&#123;sm&#125;&#125;, true)</span><br><span class="line">			trInfo.tr.SetError()</span><br><span class="line">		&#125;</span><br><span class="line">		errDesc := fmt.Sprintf(&quot;malformed method name: %q&quot;, stream.Method())</span><br><span class="line">		if err := t.WriteStatus(stream, status.New(codes.ResourceExhausted, errDesc)); err != nil &#123;</span><br><span class="line">			if trInfo != nil &#123;</span><br><span class="line">				trInfo.tr.LazyLog(&amp;fmtStringer&#123;&quot;%v&quot;, []interface&#123;&#125;&#123;err&#125;&#125;, true)</span><br><span class="line">				trInfo.tr.SetError()</span><br><span class="line">			&#125;</span><br><span class="line">			channelz.Warningf(s.channelzID, &quot;grpc: Server.handleStream failed to write status: %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		if trInfo != nil &#123;</span><br><span class="line">			trInfo.tr.Finish()</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	service := sm[:pos]</span><br><span class="line">	method := sm[pos+1:]</span><br><span class="line"></span><br><span class="line">    //在server的service映射中根据service名查找对应的service服务</span><br><span class="line">	srv, knownService := s.m[service]</span><br><span class="line">	if knownService &#123;//如果有找到</span><br><span class="line">	    //在普通的rpc方法映射中查找对应的方法描述</span><br><span class="line">		if md, ok := srv.md[method]; ok &#123;</span><br><span class="line">			s.processUnaryRPC(t, stream, srv, md, trInfo)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		//在流式rpc方法映射中查找对应的流描述</span><br><span class="line">		if sd, ok := srv.sd[method]; ok &#123;</span><br><span class="line">			s.processStreamingRPC(t, stream, srv, sd, trInfo)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//如果请求的service服务或者方法不存在，且server的配置中有配置处理位置服务的方法，则交由这个方法处理</span><br><span class="line">	// Unknown service, or known server unknown method.</span><br><span class="line">	if unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, nil, unknownDesc, trInfo)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	var errDesc string</span><br><span class="line">	if !knownService &#123;</span><br><span class="line">		errDesc = fmt.Sprintf(&quot;unknown service %v&quot;, service)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		errDesc = fmt.Sprintf(&quot;unknown method %v for service %v&quot;, method, service)</span><br><span class="line">	&#125;</span><br><span class="line">	if trInfo != nil &#123;</span><br><span class="line">		trInfo.tr.LazyPrintf(&quot;%s&quot;, errDesc)</span><br><span class="line">		trInfo.tr.SetError()</span><br><span class="line">	&#125;</span><br><span class="line">	if err := t.WriteStatus(stream, status.New(codes.Unimplemented, errDesc)); err != nil &#123;</span><br><span class="line">		if trInfo != nil &#123;</span><br><span class="line">			trInfo.tr.LazyLog(&amp;fmtStringer&#123;&quot;%v&quot;, []interface&#123;&#125;&#123;err&#125;&#125;, true)</span><br><span class="line">			trInfo.tr.SetError()</span><br><span class="line">		&#125;</span><br><span class="line">		channelz.Warningf(s.channelzID, &quot;grpc: Server.handleStream failed to write status: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if trInfo != nil &#123;</span><br><span class="line">		trInfo.tr.Finish()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看下普通一元rpc请求的processUnaryRPC（去除掉一些与主要流程没有太大关系的非核心代码，流式rpc处理方法就不贴出来的，思路是差不多的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) &#123;</span><br><span class="line">	// ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //设置压缩解压缩的配置</span><br><span class="line">	// comp and cp are used for compression.  decomp and dc are used for</span><br><span class="line">	// decompression.  If comp and decomp are both set, they are the same;</span><br><span class="line">	// however they are kept separate to ensure that at most one of the</span><br><span class="line">	// compressor/decompressor variable pairs are set for use later.</span><br><span class="line">	var comp, decomp encoding.Compressor</span><br><span class="line">	var cp Compressor</span><br><span class="line">	var dc Decompressor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// If dc is set and matches the stream&apos;s compression, use it.  Otherwise, try</span><br><span class="line">	// to find a matching registered compressor for decomp.</span><br><span class="line">	if rc := stream.RecvCompress(); s.opts.dc != nil &amp;&amp; s.opts.dc.Type() == rc &#123;</span><br><span class="line">		dc = s.opts.dc</span><br><span class="line">	&#125; else if rc != &quot;&quot; &amp;&amp; rc != encoding.Identity &#123;</span><br><span class="line">		decomp = encoding.GetCompressor(rc)</span><br><span class="line">		if decomp == nil &#123;</span><br><span class="line">			st := status.Newf(codes.Unimplemented, &quot;grpc: Decompressor is not installed for grpc-encoding %q&quot;, rc)</span><br><span class="line">			t.WriteStatus(stream, st)</span><br><span class="line">			return st.Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If cp is set, use it.  Otherwise, attempt to compress the response using</span><br><span class="line">	// the incoming message compression method.</span><br><span class="line">	//</span><br><span class="line">	// NOTE: this needs to be ahead of all handling, https://github.com/grpc/grpc-go/issues/686.</span><br><span class="line">	if s.opts.cp != nil &#123;</span><br><span class="line">		cp = s.opts.cp</span><br><span class="line">		stream.SetSendCompress(cp.Type())</span><br><span class="line">	&#125; else if rc := stream.RecvCompress(); rc != &quot;&quot; &amp;&amp; rc != encoding.Identity &#123;</span><br><span class="line">		// Legacy compressor not specified; attempt to respond with same encoding.</span><br><span class="line">		comp = encoding.GetCompressor(rc)</span><br><span class="line">		if comp != nil &#123;</span><br><span class="line">			stream.SetSendCompress(rc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var payInfo *payloadInfo</span><br><span class="line">	if sh != nil || binlog != nil &#123;</span><br><span class="line">		payInfo = &amp;payloadInfo&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//接收数据并解压缩</span><br><span class="line">	d, err := recvAndDecompress(&amp;parser&#123;r: stream&#125;, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		if st, ok := status.FromError(err); ok &#123;</span><br><span class="line">			if e := t.WriteStatus(stream, st); e != nil &#123;</span><br><span class="line">				channelz.Warningf(s.channelzID, &quot;grpc: Server.processUnaryRPC failed to write status %v&quot;, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		t.IncrMsgRecv()</span><br><span class="line">	&#125;</span><br><span class="line">	// 反序列化，最终数据放到v中，而这个v则指向服务接口实现对应方法的请求参数req</span><br><span class="line">	df := func(v interface&#123;&#125;) error &#123;</span><br><span class="line">	//反序列化请求参数</span><br><span class="line">		if err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil &#123;</span><br><span class="line">			return status.Errorf(codes.Internal, &quot;grpc: error unmarshalling request: %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		if sh != nil &#123;</span><br><span class="line">			sh.HandleRPC(stream.Context(), &amp;stats.InPayload&#123;</span><br><span class="line">				RecvTime:   time.Now(),</span><br><span class="line">				Payload:    v,</span><br><span class="line">				WireLength: payInfo.wireLength,</span><br><span class="line">				Data:       d,</span><br><span class="line">				Length:     len(d),</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">        //...</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	ctx := NewContextWithServerTransportStream(stream.Context(), stream)</span><br><span class="line">	//调用Handler,这个Handler方法是proto自动编码工具生成的。其内部会去调用service服务的对应方法。df是反序列化方法，最后一个是创建grpc.Server指定的拦截器</span><br><span class="line">	reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)</span><br><span class="line">	if appErr != nil &#123;</span><br><span class="line">		appStatus, ok := status.FromError(appErr)</span><br><span class="line">		if !ok &#123;</span><br><span class="line">			// Convert appErr if it is not a grpc status error.</span><br><span class="line">			appErr = status.Error(codes.Unknown, appErr.Error())</span><br><span class="line">			appStatus, _ = status.FromError(appErr)</span><br><span class="line">		&#125;</span><br><span class="line">		if trInfo != nil &#123;</span><br><span class="line">			trInfo.tr.LazyLog(stringer(appStatus.Message()), true)</span><br><span class="line">			trInfo.tr.SetError()</span><br><span class="line">		&#125;</span><br><span class="line">		// 写入错误信息到stream中</span><br><span class="line">		if e := t.WriteStatus(stream, appStatus); e != nil &#123;</span><br><span class="line">			channelz.Warningf(s.channelzID, &quot;grpc: Server.processUnaryRPC failed to write status: %v&quot;, e)</span><br><span class="line">		&#125;</span><br><span class="line">        //...</span><br><span class="line">		&#125;</span><br><span class="line">		return appErr</span><br><span class="line">	&#125;</span><br><span class="line">	if trInfo != nil &#123;</span><br><span class="line">		trInfo.tr.LazyLog(stringer(&quot;OK&quot;), false)</span><br><span class="line">	&#125;</span><br><span class="line">	opts := &amp;transport.Options&#123;Last: true&#125;</span><br><span class="line"></span><br><span class="line">// 序列化reply给客户端</span><br><span class="line">	if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil &#123;</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			// The entire stream is done (for unary RPC only).</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		if sts, ok := status.FromError(err); ok &#123;</span><br><span class="line">			if e := t.WriteStatus(stream, sts); e != nil &#123;</span><br><span class="line">				channelz.Warningf(s.channelzID, &quot;grpc: Server.processUnaryRPC failed to write status: %v&quot;, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			switch st := err.(type) &#123;</span><br><span class="line">			case transport.ConnectionError:</span><br><span class="line">				// Nothing to do here.</span><br><span class="line">			default:</span><br><span class="line">				panic(fmt.Sprintf(&quot;grpc: Unexpected error (%T) from sendResponse: %v&quot;, st, st))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if binlog != nil &#123;</span><br><span class="line">			h, _ := stream.Header()</span><br><span class="line">			binlog.Log(&amp;binarylog.ServerHeader&#123;</span><br><span class="line">				Header: h,</span><br><span class="line">			&#125;)</span><br><span class="line">			binlog.Log(&amp;binarylog.ServerTrailer&#123;</span><br><span class="line">				Trailer: stream.Trailer(),</span><br><span class="line">				Err:     appErr,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = t.WriteStatus(stream, statusOK)</span><br><span class="line"></span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码的主要逻辑就是从stream中读取req请求，反序列化后调用methodDesc中的handler方法，处理完请求后将响应序列化然后写入stream返回给客户端。</p>
<p>我们看一下消息解析的方法，这个方法是从buf中解析原始的数据转为protobuf序列化后的数据格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func recvAndDecompress(p *parser, s *transport.Stream, dc Decompressor, maxReceiveMessageSize int, payInfo *payloadInfo, compressor encoding.Compressor) ([]byte, error) &#123;</span><br><span class="line">// recvMsg解析出真正的消息（头5个字节：第一个字节代表是否压缩，2-5个字节消息体的长度，后面的数据全部读取给req）</span><br><span class="line">	pf, d, err := p.recvMsg(maxReceiveMessageSize)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if payInfo != nil &#123;</span><br><span class="line">		payInfo.wireLength = len(d)</span><br><span class="line">	&#125;</span><br><span class="line">// 检查压缩类型是否正确</span><br><span class="line">	if st := checkRecvPayload(pf, s.RecvCompress(), compressor != nil || dc != nil); st != nil &#123;</span><br><span class="line">		return nil, st.Err()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var size int</span><br><span class="line">	if pf == compressionMade &#123;</span><br><span class="line">		// To match legacy behavior, if the decompressor is set by WithDecompressor or RPCDecompressor,</span><br><span class="line">		// use this decompressor as the default.</span><br><span class="line">		if dc != nil &#123;</span><br><span class="line">			d, err = dc.Do(bytes.NewReader(d))</span><br><span class="line">			size = len(d)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			d, size, err = decompress(compressor, d, maxReceiveMessageSize)</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return nil, status.Errorf(codes.Internal, &quot;grpc: failed to decompress the received message %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		size = len(d)</span><br><span class="line">	&#125;</span><br><span class="line">	if size &gt; maxReceiveMessageSize &#123;</span><br><span class="line">		// TODO: Revisit the error code. Currently keep it consistent with java</span><br><span class="line">		// implementation.</span><br><span class="line">		return nil, status.Errorf(codes.ResourceExhausted, &quot;grpc: received message larger than max (%d vs. %d)&quot;, size, maxReceiveMessageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	return d, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下上面提到的proto代码工具自动生成的handler方法（以HelloTiger为例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func _TigerService_HelloTiger_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	in := new(HelloRequest)</span><br><span class="line">	//dec是传入的反序列化方法</span><br><span class="line">	if err := dec(in); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	//如果拦截器没设置，那么直接调用相应的方法</span><br><span class="line">	if interceptor == nil &#123;</span><br><span class="line">		return srv.(TigerServiceServer).HelloTiger(ctx, in)</span><br><span class="line">	&#125;</span><br><span class="line">	//servcie服务信息</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: &quot;/server_hello_proto.TigerService/HelloTiger&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	//回调</span><br><span class="line">	handler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123;</span><br><span class="line">		return srv.(TigerServiceServer).HelloTiger(ctx, req.(*HelloRequest))</span><br><span class="line">	&#125;</span><br><span class="line">	//有拦截器，先调用拦截器方法，传入回调函数</span><br><span class="line">	return interceptor(ctx, in, info, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下中的NewContextWithServerTransportStream函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//该函数基于现有ctx生成新的context，并将stream保存到上面</span><br><span class="line">// NewContextWithServerTransportStream creates a new context from ctx and</span><br><span class="line">// attaches stream to it.</span><br><span class="line">//</span><br><span class="line">// This API is EXPERIMENTAL.</span><br><span class="line">func NewContextWithServerTransportStream(ctx context.Context, stream ServerTransportStream) context.Context &#123;</span><br><span class="line">	return context.WithValue(ctx, streamKey&#123;&#125;, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//该接口用于服务端设置传递给客户端的header</span><br><span class="line">// ServerTransportStream is a minimal interface that a transport stream must</span><br><span class="line">// implement. This can be used to mock an actual transport stream for tests of</span><br><span class="line">// handler code that use, for example, grpc.SetHeader (which requires some</span><br><span class="line">// stream to be in context).</span><br><span class="line">//</span><br><span class="line">// See also NewContextWithServerTransportStream.</span><br><span class="line">//</span><br><span class="line">// This API is EXPERIMENTAL.</span><br><span class="line">type ServerTransportStream interface &#123;</span><br><span class="line">	Method() string</span><br><span class="line">	SetHeader(md metadata.MD) error</span><br><span class="line">	SendHeader(md metadata.MD) error</span><br><span class="line">	SetTrailer(md metadata.MD) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们从代码中可以看出，调用NewContextWithServerTransportStream函数时传入的是当前请求的stream.context()</p>
<p>我们再来看下 stream.ctx的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">// operateHeader takes action on the decoded headers.</span><br><span class="line">func (t *http2Server) operateHeaders(frame *http2.MetaHeadersFrame, handle func(*Stream), traceCtx func(context.Context, string) context.Context) (fatal bool) &#123;</span><br><span class="line">	streamID := frame.Header().StreamID</span><br><span class="line">	state := &amp;decodeState&#123;</span><br><span class="line">		serverSide: true,</span><br><span class="line">	&#125;</span><br><span class="line">	//解析HEADER帧，获取HEADER帧中的各个字段</span><br><span class="line">	if err := state.decodeHeader(frame); err != nil &#123;</span><br><span class="line">		if se, ok := status.FromError(err); ok &#123;</span><br><span class="line">			t.controlBuf.put(&amp;cleanupStream&#123;</span><br><span class="line">				streamID: streamID,</span><br><span class="line">				rst:      true,</span><br><span class="line">				rstCode:  statusCodeConvTab[se.Code()],</span><br><span class="line">				onWrite:  func() &#123;&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buf := newRecvBuffer()</span><br><span class="line">	s := &amp;Stream&#123;</span><br><span class="line">		id:             streamID,</span><br><span class="line">		st:             t,</span><br><span class="line">		buf:            buf,</span><br><span class="line">		fc:             &amp;inFlow&#123;limit: uint32(t.initialWindowSize)&#125;,</span><br><span class="line">		recvCompress:   state.data.encoding,</span><br><span class="line">		method:         state.data.method,</span><br><span class="line">		contentSubtype: state.data.contentSubtype,</span><br><span class="line">	&#125;</span><br><span class="line">	if frame.StreamEnded() &#123;</span><br><span class="line">		// s is just created by the caller. No lock needed.</span><br><span class="line">		s.state = streamReadDone</span><br><span class="line">	&#125;</span><br><span class="line">	if state.data.timeoutSet &#123;</span><br><span class="line">		s.ctx, s.cancel = context.WithTimeout(t.ctx, state.data.timeout)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		s.ctx, s.cancel = context.WithCancel(t.ctx)</span><br><span class="line">	&#125;</span><br><span class="line">	pr := &amp;peer.Peer&#123;</span><br><span class="line">		Addr: t.remoteAddr,</span><br><span class="line">	&#125;</span><br><span class="line">	// Attach Auth info if there is any.</span><br><span class="line">	if t.authInfo != nil &#123;</span><br><span class="line">		pr.AuthInfo = t.authInfo</span><br><span class="line">	&#125;</span><br><span class="line">	s.ctx = peer.NewContext(s.ctx, pr)</span><br><span class="line">	// Attach the received metadata to the context.</span><br><span class="line">	if len(state.data.mdata) &gt; 0 &#123;</span><br><span class="line">	 // 这里会将state.mdata保存到新的context中</span><br><span class="line">		s.ctx = metadata.NewIncomingContext(s.ctx, state.data.mdata)</span><br><span class="line">	&#125;</span><br><span class="line">	if state.data.statsTags != nil &#123;</span><br><span class="line">		s.ctx = stats.SetIncomingTags(s.ctx, state.data.statsTags)</span><br><span class="line">	&#125;</span><br><span class="line">	if state.data.statsTrace != nil &#123;</span><br><span class="line">		s.ctx = stats.SetIncomingTrace(s.ctx, state.data.statsTrace)</span><br><span class="line">	&#125;</span><br><span class="line">	if t.inTapHandle != nil &#123;</span><br><span class="line">		var err error</span><br><span class="line">		info := &amp;tap.Info&#123;</span><br><span class="line">			FullMethodName: state.data.method,</span><br><span class="line">		&#125;</span><br><span class="line">		s.ctx, err = t.inTapHandle(s.ctx, info)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			warningf(&quot;transport: http2Server.operateHeaders got an error from InTapHandle: %v&quot;, err)</span><br><span class="line">			t.controlBuf.put(&amp;cleanupStream&#123;</span><br><span class="line">				streamID: s.id,</span><br><span class="line">				rst:      true,</span><br><span class="line">				rstCode:  http2.ErrCodeRefusedStream,</span><br><span class="line">				onWrite:  func() &#123;&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">			s.cancel()</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.mu.Lock()</span><br><span class="line">	if t.state != reachable &#123;</span><br><span class="line">		t.mu.Unlock()</span><br><span class="line">		s.cancel()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	if uint32(len(t.activeStreams)) &gt;= t.maxStreams &#123;</span><br><span class="line">		t.mu.Unlock()</span><br><span class="line">		t.controlBuf.put(&amp;cleanupStream&#123;</span><br><span class="line">			streamID: streamID,</span><br><span class="line">			rst:      true,</span><br><span class="line">			rstCode:  http2.ErrCodeRefusedStream,</span><br><span class="line">			onWrite:  func() &#123;&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		s.cancel()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	if streamID%2 != 1 || streamID &lt;= t.maxStreamID &#123;</span><br><span class="line">		t.mu.Unlock()</span><br><span class="line">		// illegal gRPC stream id.</span><br><span class="line">		errorf(&quot;transport: http2Server.HandleStreams received an illegal stream id: %v&quot;, streamID)</span><br><span class="line">		s.cancel()</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	t.maxStreamID = streamID</span><br><span class="line">	t.activeStreams[streamID] = s</span><br><span class="line">	if len(t.activeStreams) == 1 &#123;</span><br><span class="line">		t.idle = time.Time&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.mu.Unlock()</span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		atomic.AddInt64(&amp;t.czData.streamsStarted, 1)</span><br><span class="line">		atomic.StoreInt64(&amp;t.czData.lastStreamCreatedTime, time.Now().UnixNano())</span><br><span class="line">	&#125;</span><br><span class="line">	s.requestRead = func(n int) &#123;</span><br><span class="line">		t.adjustWindow(s, uint32(n))</span><br><span class="line">	&#125;</span><br><span class="line">	s.ctx = traceCtx(s.ctx, s.method)</span><br><span class="line">	if t.stats != nil &#123;</span><br><span class="line">		s.ctx = t.stats.TagRPC(s.ctx, &amp;stats.RPCTagInfo&#123;FullMethodName: s.method&#125;)</span><br><span class="line">		inHeader := &amp;stats.InHeader&#123;</span><br><span class="line">			FullMethod:  s.method,</span><br><span class="line">			RemoteAddr:  t.remoteAddr,</span><br><span class="line">			LocalAddr:   t.localAddr,</span><br><span class="line">			Compression: s.recvCompress,</span><br><span class="line">			WireLength:  int(frame.Header().Length),</span><br><span class="line">			Header:      metadata.MD(state.data.mdata).Copy(),</span><br><span class="line">		&#125;</span><br><span class="line">		t.stats.HandleRPC(s.ctx, inHeader)</span><br><span class="line">	&#125;</span><br><span class="line">	s.ctxDone = s.ctx.Done()</span><br><span class="line">	s.wq = newWriteQuota(defaultWriteQuota, s.ctxDone)</span><br><span class="line">	s.trReader = &amp;transportReader&#123;</span><br><span class="line">		reader: &amp;recvBufferReader&#123;</span><br><span class="line">			ctx:        s.ctx,</span><br><span class="line">			ctxDone:    s.ctxDone,</span><br><span class="line">			recv:       s.buf,</span><br><span class="line">			freeBuffer: t.bufferPool.put,</span><br><span class="line">		&#125;,</span><br><span class="line">		windowHandler: func(n int) &#123;</span><br><span class="line">			t.updateWindow(s, uint32(n))</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	// Register the stream with loopy.</span><br><span class="line">	t.controlBuf.put(&amp;registerStream&#123;</span><br><span class="line">		streamID: s.id,</span><br><span class="line">		wq:       s.wq,</span><br><span class="line">	&#125;)</span><br><span class="line">	handle(s)</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当收到一个Header帧，就表明有新的rpc请求到来，这时候就会解析header帧并创建stream，在创建stream的时候，会把用户自定义的header字段保存到stream.context中</p>
<p>接下来看一下返回给客户端响应的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) sendResponse(t transport.ServerTransport, stream *transport.Stream, msg interface&#123;&#125;, cp Compressor, opts *transport.Options, comp encoding.Compressor) error &#123;</span><br><span class="line">    //反序列化响应消息</span><br><span class="line">	data, err := encode(s.getCodec(stream.ContentSubtype()), msg)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		channelz.Error(s.channelzID, &quot;grpc: server failed to encode response: &quot;, err)</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	//压缩</span><br><span class="line">	compData, err := compress(data, cp, comp)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		channelz.Error(s.channelzID, &quot;grpc: server failed to compress response: &quot;, err)</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	//创建消息体头部</span><br><span class="line">	hdr, payload := msgHeader(data, compData)</span><br><span class="line">	// TODO(dfawley): should we be checking len(data) instead?</span><br><span class="line">	if len(payload) &gt; s.opts.maxSendMessageSize &#123;</span><br><span class="line">		return status.Errorf(codes.ResourceExhausted, &quot;grpc: trying to send message larger than max (%d vs. %d)&quot;, len(payload), s.opts.maxSendMessageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	//写入stream</span><br><span class="line">	err = t.Write(stream, hdr, payload, opts)</span><br><span class="line">	if err == nil &amp;&amp; s.opts.statsHandler != nil &#123;</span><br><span class="line">		s.opts.statsHandler.HandleRPC(stream.Context(), outPayload(false, msg, data, payload, time.Now()))</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// Write converts the data into HTTP2 data frame and sends it out. Non-nil error</span><br><span class="line">// is returns if it fails (e.g., framing error, transport error).</span><br><span class="line">func (t *http2Server) Write(s *Stream, hdr []byte, data []byte, opts *Options) error &#123;</span><br><span class="line">//如果Header帧还没发送，先发送HEADER帧</span><br><span class="line">	if !s.isHeaderSent() &#123; // Headers haven&apos;t been written yet.</span><br><span class="line">		if err := t.WriteHeader(s, nil); err != nil &#123;</span><br><span class="line">			if _, ok := err.(ConnectionError); ok &#123;</span><br><span class="line">				return err</span><br><span class="line">			&#125;</span><br><span class="line">			// TODO(mmukhi, dfawley): Make sure this is the right code to return.</span><br><span class="line">			return status.Errorf(codes.Internal, &quot;transport: %v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// Writing headers checks for this condition.</span><br><span class="line">		if s.getState() == streamDone &#123;</span><br><span class="line">			// TODO(mmukhi, dfawley): Should the server write also return io.EOF?</span><br><span class="line">			s.cancel()</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-t.done:</span><br><span class="line">				return ErrConnClosing</span><br><span class="line">			default:</span><br><span class="line">			&#125;</span><br><span class="line">			return ContextErr(s.ctx.Err())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Add some data to header frame so that we can equally distribute bytes across frames.</span><br><span class="line">	emptyLen := http2MaxFrameLen - len(hdr)</span><br><span class="line">	if emptyLen &gt; len(data) &#123;</span><br><span class="line">		emptyLen = len(data)</span><br><span class="line">	&#125;</span><br><span class="line">	hdr = append(hdr, data[:emptyLen]...)</span><br><span class="line">	data = data[emptyLen:]</span><br><span class="line">	//构造数据DATA帧</span><br><span class="line">	df := &amp;dataFrame&#123;</span><br><span class="line">		streamID:    s.id,</span><br><span class="line">		h:           hdr,</span><br><span class="line">		d:           data,</span><br><span class="line">		onEachWrite: t.setResetPingStrikes,</span><br><span class="line">	&#125;</span><br><span class="line">	if err := s.wq.get(int32(len(hdr) + len(data))); err != nil &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-t.done:</span><br><span class="line">			return ErrConnClosing</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">		return ContextErr(s.ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">	//将DATA帧加入到发送队列</span><br><span class="line">	return t.controlBuf.put(df)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/grpc-go 客户端invoke调用源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/grpc-go 客户端invoke调用源码分析/" itemprop="url">grpc-go 客户端invoke调用源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T23:46:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:1235&quot;, grpc.WithInsecure())</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client := server_hello_proto.NewTigerServiceClient(conn)</span><br><span class="line">	response, err := client.HelloTiger(context.Background(), &amp;server_hello_proto.HelloRequest&#123;</span><br><span class="line">		Name: &quot;ban&quot;,</span><br><span class="line">		Age:  11,</span><br><span class="line">	&#125;)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一篇我们分析了Dial建立连接的流程。现在继续往下分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client := server_hello_proto.NewTigerServiceClient(conn)</span><br></pre></td></tr></table></figure>
<p>这里是使用pb文件的代码去新建一个连接client，其实也就是使用一个结构体类型(TigerServiceClient)的值保存clientConn连接属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type tigerServiceClient struct &#123;</span><br><span class="line">	cc *grpc.ClientConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个TigerServiceClient类型实现了TigerServiceClient接口，也就是实现了根据proto定义的rppc service 接口编译自动生成的客户端stub api接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TigerServiceClient interface &#123;</span><br><span class="line">	HelloTiger(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HelloTiger这个方法入参有三个，查看grpc.CallOption这个参数类型，这是一个接口类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CallOption configures a Call before it starts or extracts information from</span><br><span class="line">// a Call after it completes.</span><br><span class="line">type CallOption interface &#123;</span><br><span class="line">	// before is called before the call is sent to any server.  If before</span><br><span class="line">	// returns a non-nil error, the RPC fails with that error.</span><br><span class="line">	before(*callInfo) error</span><br><span class="line"></span><br><span class="line">	// after is called after the call has completed.  after cannot return an</span><br><span class="line">	// error, so any failures should be reported via output parameters.</span><br><span class="line">	after(*callInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个接口类型有before和after方法，我们可以实现这个接口，在RPC方法调用前后会调用before和after方法去执行我们的实现逻辑。</p>
<p>然后我们再看客户端stub api的方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (c *tigerServiceClient) HelloTiger(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error) &#123;</span><br><span class="line">	out := new(HelloResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, &quot;/server_hello_proto.TigerService/HelloTiger&quot;, in, out, opts...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return out, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的核心是Invoke调用，也就是本篇分析的重点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Invoke sends the RPC request on the wire and returns after response is</span><br><span class="line">// received.  This is typically called by generated code.</span><br><span class="line">// Invoke 在逻辑链接ClientCoon上发送RPC请求，收到响应后返回。Invoke通常由proto代码生成工具生成的stub代码发起调用</span><br><span class="line">//</span><br><span class="line">// All errors returned by Invoke are compatible with the status package.</span><br><span class="line">//所有Invoke调用返回的错误都与 status 包兼容</span><br><span class="line">func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply interface&#123;&#125;, opts ...CallOption) error &#123;</span><br><span class="line">	// allow interceptor to see all applicable call options, which means those</span><br><span class="line">	// configured as defaults from dial option as well as per-call options</span><br><span class="line">	//将Dial初始化的callOption与Invoke调用传入的callOption合并到一个切片，允许拦截器去访问这些调用可选配置callOptions</span><br><span class="line">	opts = combine(cc.dopts.callOptions, opts)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if cc.dopts.unaryInt != nil &#123;</span><br><span class="line">	    //拦截器不为空，就调用这个方法（实际上也要调用invoke函数）</span><br><span class="line">		return cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...)</span><br><span class="line">	&#125;</span><br><span class="line">	//拦截器为空，直接调用invoke函数</span><br><span class="line">	return invoke(ctx, method, args, reply, cc, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invoke函数声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func invoke(ctx context.Context, method string, req, reply interface&#123;&#125;, cc *ClientConn, opts ...CallOption) error &#123;</span><br><span class="line">//获取传输层 Trasport 并组合封装到 ClientStream 中返回，在这块会涉及负载均衡、超时控制、 Encoding、 Stream 的动作，与服务端基本一致的行为。</span><br><span class="line">	cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	//发送请求</span><br><span class="line">	if err := cs.SendMsg(req); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	//返回响应</span><br><span class="line">	return cs.RecvMsg(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建客户端流对象时，会循环调用callOption的before方法，做一些发送请求前的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for _, o := range opts &#123;</span><br><span class="line">	if err := o.before(c); err != nil &#123;</span><br><span class="line">		return nil, toRPCErr(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送请求SendMsg方法声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (cs *clientStream) SendMsg(m interface&#123;&#125;) (err error) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err != nil &amp;&amp; err != io.EOF &#123;</span><br><span class="line">			// Call finish on the client stream for errors generated by this SendMsg</span><br><span class="line">			// call, as these indicate problems created by this client.  (Transport</span><br><span class="line">			// errors are converted to an io.EOF error in csAttempt.sendMsg; the real</span><br><span class="line">			// error will be returned from RecvMsg eventually in that case, or be</span><br><span class="line">			// retried.)</span><br><span class="line">			cs.finish(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	// 判断客户端流是否已关闭</span><br><span class="line">	if cs.sentLast &#123;</span><br><span class="line">		return status.Errorf(codes.Internal, &quot;SendMsg called after CloseSend&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	// 判断当前流是否是客户端流</span><br><span class="line">	if !cs.desc.ClientStreams &#123;</span><br><span class="line">		cs.sentLast = true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //对请求信息预处理，序列化、压缩，生成</span><br><span class="line">	// load hdr, payload, data</span><br><span class="line">	hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// TODO(dfawley): should we be checking len(data) instead?</span><br><span class="line">	//判断压缩+序列化后的消息体总字节长度是否大于预设的 maxSendMessageSize（预设值为 math.MaxInt32），若超出则提示错误</span><br><span class="line">	if len(payload) &gt; *cs.callInfo.maxSendMessageSize &#123;</span><br><span class="line">		return status.Errorf(codes.ResourceExhausted, &quot;trying to send message larger than max (%d vs. %d)&quot;, len(payload), *cs.callInfo.maxSendMessageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	msgBytes := data // Store the pointer before setting to nil. For binary logging.</span><br><span class="line">	// 创建发送消息的函数</span><br><span class="line">	op := func(a *csAttempt) error &#123;</span><br><span class="line">	    //真正发送数据的地方</span><br><span class="line">		err := a.sendMsg(m, hdr, payload, data)</span><br><span class="line">		// nil out the message and uncomp when replaying; they are only needed for</span><br><span class="line">		// stats which is disabled for subsequent attempts.</span><br><span class="line">		m, data = nil, nil</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	// 开始发送（带重试机制）</span><br><span class="line">	err = cs.withRetry(op, func() &#123; cs.bufferForRetryLocked(len(hdr)+len(payload), op) &#125;)</span><br><span class="line">	if cs.binlog != nil &amp;&amp; err == nil &#123;</span><br><span class="line">		cs.binlog.Log(&amp;binarylog.ClientMessage&#123;</span><br><span class="line">			OnClientSide: true,</span><br><span class="line">			Message:      msgBytes,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端流对象接收响应信息方法声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">func (cs *clientStream) RecvMsg(m interface&#123;&#125;) error &#123;</span><br><span class="line">	if cs.binlog != nil &amp;&amp; !cs.serverHeaderBinlogged &#123;</span><br><span class="line">		// Call Header() to binary log header if it&apos;s not already logged.</span><br><span class="line">		cs.Header()</span><br><span class="line">	&#125;</span><br><span class="line">	var recvInfo *payloadInfo</span><br><span class="line">	if cs.binlog != nil &#123;</span><br><span class="line">		recvInfo = &amp;payloadInfo&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	  //接收服务端结果，并且反序列化，填充到m对象上，m就是返回值</span><br><span class="line">	err := cs.withRetry(func(a *csAttempt) error &#123;</span><br><span class="line">		return a.recvMsg(m, recvInfo)</span><br><span class="line">	&#125;, cs.commitAttemptLocked)</span><br><span class="line">	if cs.binlog != nil &amp;&amp; err == nil &#123;</span><br><span class="line">		cs.binlog.Log(&amp;binarylog.ServerMessage&#123;</span><br><span class="line">			OnClientSide: true,</span><br><span class="line">			Message:      recvInfo.uncompressedBytes,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	if err != nil || !cs.desc.ServerStreams &#123;</span><br><span class="line">		// err != nil or non-server-streaming indicates end of stream.</span><br><span class="line">		cs.finish(err)</span><br><span class="line"></span><br><span class="line">		if cs.binlog != nil &#123;</span><br><span class="line">			// finish will not log Trailer. Log Trailer here.</span><br><span class="line">			logEntry := &amp;binarylog.ServerTrailer&#123;</span><br><span class="line">				OnClientSide: true,</span><br><span class="line">				Trailer:      cs.Trailer(),</span><br><span class="line">				Err:          err,</span><br><span class="line">			&#125;</span><br><span class="line">			if logEntry.Err == io.EOF &#123;</span><br><span class="line">				logEntry.Err = nil</span><br><span class="line">			&#125;</span><br><span class="line">			if peer, ok := peer.FromContext(cs.Context()); ok &#123;</span><br><span class="line">				logEntry.PeerAddr = peer.Addr</span><br><span class="line">			&#125;</span><br><span class="line">			cs.binlog.Log(logEntry)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/grpc-go 客户端Dial过程源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/grpc-go 客户端Dial过程源码分析/" itemprop="url">grpc-go 客户端Dial过程源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T23:44:13+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言：最近做了小组内的分享，是关于浅谈RPC与gRpc源码分析。所以将分享的记录发到个人博客上来。接下来的几篇文章都是gRPC源码分析的个人理解，如有错误，还烦请指出。</p>
<p>源码分析所用案例github仓库地址：<a href="https://github.com/BansheeLW/gRPCTest" target="_blank" rel="noopener">https://github.com/BansheeLW/gRPCTest</a></p>
<p>客户端建立链接发送一次请求获取响应代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:1235&quot;, grpc.WithInsecure())</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client := server_hello_proto.NewTigerServiceClient(conn)</span><br><span class="line">	response, err := client.HelloTiger(context.Background(), &amp;server_hello_proto.HelloRequest&#123;</span><br><span class="line">		Name: &quot;ban&quot;,</span><br><span class="line">		Age:  11,</span><br><span class="line">	&#125;)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(response)</span><br></pre></td></tr></table></figure></p>
<p>首先来看 Dial函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Dial creates a client connection to the given target.</span><br><span class="line">func Dial(target string, opts ...DialOption) (*ClientConn, error) &#123;</span><br><span class="line">	return DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Dial函数声明可以看出，Dial函数实际上是对DialContext的一层封装，Dial函数接收两个参数，target是连接地址，opts是可变长参数，接受一个元素类型为DialOptionl的切片。</p>
<p>DialContext入参多了一个context</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// DialOption configures how we set up the connection.</span><br><span class="line">type DialOption interface &#123;</span><br><span class="line">	apply(*dialOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，DialOption是一个接口类型，有一个apply方法（接收一个dialOption的指针类型）。</p>
<p>接下来看一下使用的地方<br><figure class="highlight plain"><figcaption><span>DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	cc := &amp;ClientConn&#123;</span><br><span class="line">		target:            target,</span><br><span class="line">		csMgr:             &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">		conns:             make(map[*addrConn]struct&#123;&#125;),</span><br><span class="line">		dopts:             defaultDialOptions(),</span><br><span class="line">		blockingpicker:    newPickerWrapper(),</span><br><span class="line">		czData:            new(channelzData),</span><br><span class="line">		firstResolveEvent: grpcsync.NewEvent(),</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	for _, opt := range opts &#123;</span><br><span class="line">		opt.apply(&amp;cc.dopts)</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看一下grpc中如何生成实现DialOption接口的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// EmptyDialOption does not alter the dial configuration. It can be embedded in</span><br><span class="line">// another structure to build custom dial options.</span><br><span class="line">//</span><br><span class="line">// This API is EXPERIMENTAL.</span><br><span class="line">type EmptyDialOption struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (EmptyDialOption) apply(*dialOptions) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// funcDialOption wraps a function that modifies dialOptions into an</span><br><span class="line">// implementation of the DialOption interface.</span><br><span class="line">type funcDialOption struct &#123;</span><br><span class="line">	f func(*dialOptions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fdo *funcDialOption) apply(do *dialOptions) &#123;</span><br><span class="line">	fdo.f(do)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newFuncDialOption(f func(*dialOptions)) *funcDialOption &#123;</span><br><span class="line">	return &amp;funcDialOption&#123;</span><br><span class="line">		f: f,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>grpc包中提供了两个实现了DialOption的类型方便使用者去生成参数，特别是这个 funcDialOption 类型 ，提供了new方法得以让使用者去注入逻辑处理函数。</p>
<p>我们在Dial中传入的参数，grpc.WithInsecure(),其函数体的逻辑就是调用newFuncDialOption函数传入一个对clientCoon的secure属性进行设置(关闭客户端连接校验)的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// WithInsecure returns a DialOption which disables transport security for this</span><br><span class="line">// ClientConn. Note that transport security is required unless WithInsecure is</span><br><span class="line">// set.</span><br><span class="line">func WithInsecure() DialOption &#123;</span><br><span class="line">	return newFuncDialOption(func(o *dialOptions) &#123;</span><br><span class="line">		o.insecure = true</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一下dialOptions的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// dialOptions configure a Dial call. dialOptions are set by the DialOption</span><br><span class="line">// values passed to Dial.</span><br><span class="line">type dialOptions struct &#123;</span><br><span class="line">	unaryInt  UnaryClientInterceptor  //一元拦截器</span><br><span class="line">	streamInt StreamClientInterceptor //流式拦截器</span><br><span class="line">	</span><br><span class="line">	chainUnaryInts  []UnaryClientInterceptor</span><br><span class="line">	chainStreamInts []StreamClientInterceptor</span><br><span class="line"></span><br><span class="line">	cp          Compressor  //压缩</span><br><span class="line">	dc          Decompressor //解压缩</span><br><span class="line">	bs          internalbackoff.Strategy //重试策略</span><br><span class="line">	block       bool    //拨号是否阻塞</span><br><span class="line">	insecure    bool    //安全校验</span><br><span class="line">	timeout     time.Duration</span><br><span class="line">	scChan      &lt;-chan ServiceConfig</span><br><span class="line">	authority   string</span><br><span class="line">	copts       transport.ConnectOptions</span><br><span class="line">	callOptions []CallOption</span><br><span class="line">	// This is used by v1 balancer dial option WithBalancer to support v1</span><br><span class="line">	// balancer, and also by WithBalancerName dial option.</span><br><span class="line">	balancerBuilder             balancer.Builder</span><br><span class="line">	channelzParentID            int64</span><br><span class="line">	disableServiceConfig        bool</span><br><span class="line">	disableRetry                bool</span><br><span class="line">	disableHealthCheck          bool</span><br><span class="line">	healthCheckFunc             internal.HealthChecker</span><br><span class="line">	minConnectTimeout           func() time.Duration</span><br><span class="line">	defaultServiceConfig        *ServiceConfig // defaultServiceConfig is parsed from defaultServiceConfigRawJSON.</span><br><span class="line">	defaultServiceConfigRawJSON *string</span><br><span class="line">	// This is used by ccResolverWrapper to backoff between successive calls to</span><br><span class="line">	// resolver.ResolveNow(). The user will have no need to configure this, but</span><br><span class="line">	// we need to be able to configure this in tests.</span><br><span class="line">	resolveNowBackoff func(int) time.Duration</span><br><span class="line">	resolvers         []resolver.Builder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上说了一堆，其实就是客户端拨号连接时，有一些默认配置，如果需要修改这些配置，就需要传递实现的了DialOption接口的类型值切片进来覆盖默认配置。gRPC包通过暴露接口的形式来实现对包内不可导出类型属性的修改。</p>
<h4 id="ClientConn"><a href="#ClientConn" class="headerlink" title="ClientConn"></a>ClientConn</h4><p>整个Dial拨号调用过程中，ClientConn是最重要的类型，它是一个结构体类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ClientConn represents a virtual connection to a conceptual endpoint, to</span><br><span class="line">// perform RPCs.</span><br><span class="line">//</span><br><span class="line">// A ClientConn is free to have zero or more actual connections to the endpoint</span><br><span class="line">// based on configuration, load, etc. It is also free to determine which actual</span><br><span class="line">// endpoints to use and may change it every RPC, permitting client-side load</span><br><span class="line">// balancing.</span><br><span class="line">//</span><br><span class="line">// A ClientConn encapsulates a range of functionality including name</span><br><span class="line">// resolution, TCP connection establishment (with retries and backoff) and TLS</span><br><span class="line">// handshakes. It also handles errors on established connections by</span><br><span class="line">// re-resolving the name and reconnecting.</span><br><span class="line">type ClientConn struct &#123;</span><br><span class="line">	ctx    context.Context</span><br><span class="line">	cancel context.CancelFunc</span><br><span class="line"></span><br><span class="line">	target       string //目标地址</span><br><span class="line">	parsedTarget resolver.Target //地址解析器</span><br><span class="line">	authority    string</span><br><span class="line">	dopts        dialOptions //拨号建立链接相关参数</span><br><span class="line">	csMgr        *connectivityStateManager //链接状态管理器</span><br><span class="line"></span><br><span class="line">	balancerBuildOpts balancer.BuildOptions</span><br><span class="line">	blockingpicker    *pickerWrapper</span><br><span class="line"></span><br><span class="line">	mu              sync.RWMutex</span><br><span class="line">	resolverWrapper *ccResolverWrapper</span><br><span class="line">	sc              *ServiceConfig</span><br><span class="line">	conns           map[*addrConn]struct&#123;&#125;</span><br><span class="line">	// Keepalive parameter can be updated if a GoAway is received.</span><br><span class="line">	mkp             keepalive.ClientParameters //长连接保活相关</span><br><span class="line">	curBalancerName string</span><br><span class="line">	balancerWrapper *ccBalancerWrapper</span><br><span class="line">	retryThrottler  atomic.Value</span><br><span class="line"></span><br><span class="line">	firstResolveEvent *grpcsync.Event</span><br><span class="line"></span><br><span class="line">	channelzID int64 // channelz unique identification number</span><br><span class="line">	czData     *channelzData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，ClientCoon是一个终端（客户端）逻辑TCP链接，用来执行RPC相关业务。它封装了一些功能：命名（目标地址）解析、建立TCP连接（带重试和回退），及建立连接过程中的一些错误处理。</p>
<p>ClientCoon结构体包含dialOptions类型的字段，这个dialOptions结构体类型还有一个属性ConnectOptions需要我们关注下，这个结构体类型包含了所有与服务端交流是相关的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// ConnectOptions covers all relevant options for communicating with the server.</span><br><span class="line">type ConnectOptions struct &#123;</span><br><span class="line">	// UserAgent is the application user agent.</span><br><span class="line">	UserAgent string</span><br><span class="line">	// Dialer specifies how to dial a network address.</span><br><span class="line">	Dialer func(context.Context, string) (net.Conn, error)</span><br><span class="line">	// FailOnNonTempDialError specifies if gRPC fails on non-temporary dial errors.</span><br><span class="line">	FailOnNonTempDialError bool</span><br><span class="line">	// PerRPCCredentials stores the PerRPCCredentials required to issue RPCs.</span><br><span class="line">	PerRPCCredentials []credentials.PerRPCCredentials</span><br><span class="line">	// TransportCredentials stores the Authenticator required to setup a client</span><br><span class="line">	// connection. Only one of TransportCredentials and CredsBundle is non-nil.</span><br><span class="line">	TransportCredentials credentials.TransportCredentials</span><br><span class="line">	// CredsBundle is the credentials bundle to be used. Only one of</span><br><span class="line">	// TransportCredentials and CredsBundle is non-nil.</span><br><span class="line">	CredsBundle credentials.Bundle</span><br><span class="line">	// KeepaliveParams stores the keepalive parameters.</span><br><span class="line">	KeepaliveParams keepalive.ClientParameters</span><br><span class="line">	// StatsHandler stores the handler for stats.</span><br><span class="line">	StatsHandler stats.Handler</span><br><span class="line">	// InitialWindowSize sets the initial window size for a stream.</span><br><span class="line">	InitialWindowSize int32</span><br><span class="line">	// InitialConnWindowSize sets the initial window size for a connection.</span><br><span class="line">	InitialConnWindowSize int32</span><br><span class="line">	// WriteBufferSize sets the size of write buffer which in turn determines how much data can be batched before it&apos;s written on the wire.</span><br><span class="line">	WriteBufferSize int</span><br><span class="line">	// ReadBufferSize sets the size of read buffer, which in turn determines how much data can be read at most for one read syscall.</span><br><span class="line">	ReadBufferSize int</span><br><span class="line">	// ChannelzParentID sets the addrConn id which initiate the creation of this client transport.</span><br><span class="line">	ChannelzParentID int64</span><br><span class="line">	// MaxHeaderListSize sets the max (uncompressed) size of header list that is prepared to be received.</span><br><span class="line">	MaxHeaderListSize *uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整体调用流程"><a href="#整体调用流程" class="headerlink" title="整体调用流程"></a>整体调用流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123;</span><br><span class="line">	cc := &amp;ClientConn&#123;</span><br><span class="line">		target:            target,</span><br><span class="line">		csMgr:             &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">		conns:             make(map[*addrConn]struct&#123;&#125;),</span><br><span class="line">		dopts:             defaultDialOptions(),</span><br><span class="line">		blockingpicker:    newPickerWrapper(),</span><br><span class="line">		czData:            new(channelzData),</span><br><span class="line">		firstResolveEvent: grpcsync.NewEvent(),</span><br><span class="line">	&#125;</span><br><span class="line">	cc.retryThrottler.Store((*retryThrottler)(nil))</span><br><span class="line">	cc.ctx, cc.cancel = context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">//连接相关默认配置覆盖</span><br><span class="line">	for _, opt := range opts &#123;</span><br><span class="line">		opt.apply(&amp;cc.dopts)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//拦截器相关设置(将拦截器串联起来形成一个调用链，其实就是放入cc.dopts.chainUnaryInts或cc.dopts.chainStreamInts里)</span><br><span class="line">	chainUnaryClientInterceptors(cc)</span><br><span class="line">	chainStreamClientInterceptors(cc)</span><br><span class="line"></span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			cc.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">// RPC运行时信息收集工具相关处理</span><br><span class="line">	if channelz.IsOn() &#123;</span><br><span class="line">		if cc.dopts.channelzParentID != 0 &#123;</span><br><span class="line">			cc.channelzID = channelz.RegisterChannel(&amp;channelzChannel&#123;cc&#125;, cc.dopts.channelzParentID, target)</span><br><span class="line">			channelz.AddTraceEvent(cc.channelzID, 0, &amp;channelz.TraceEventDesc&#123;</span><br><span class="line">				Desc:     &quot;Channel Created&quot;,</span><br><span class="line">				Severity: channelz.CtINFO,</span><br><span class="line">				Parent: &amp;channelz.TraceEventDesc&#123;</span><br><span class="line">					Desc:     fmt.Sprintf(&quot;Nested Channel(id:%d) created&quot;, cc.channelzID),</span><br><span class="line">					Severity: channelz.CtINFO,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cc.channelzID = channelz.RegisterChannel(&amp;channelzChannel&#123;cc&#125;, 0, target)</span><br><span class="line">			channelz.Info(cc.channelzID, &quot;Channel Created&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		cc.csMgr.channelzID = cc.channelzID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//tls连接加密证书相关检查</span><br><span class="line">	if !cc.dopts.insecure &#123;</span><br><span class="line">		if cc.dopts.copts.TransportCredentials == nil &amp;&amp; cc.dopts.copts.CredsBundle == nil &#123;</span><br><span class="line">			return nil, errNoTransportSecurity</span><br><span class="line">		&#125;</span><br><span class="line">		if cc.dopts.copts.TransportCredentials != nil &amp;&amp; cc.dopts.copts.CredsBundle != nil &#123;</span><br><span class="line">			return nil, errTransportCredsAndBundle</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if cc.dopts.copts.TransportCredentials != nil || cc.dopts.copts.CredsBundle != nil &#123;</span><br><span class="line">			return nil, errCredentialsConflict</span><br><span class="line">		&#125;</span><br><span class="line">		for _, cd := range cc.dopts.copts.PerRPCCredentials &#123;</span><br><span class="line">			if cd.RequireTransportSecurity() &#123;</span><br><span class="line">				return nil, errTransportCredentialsMissing</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果提供了服务配置</span><br><span class="line">	if cc.dopts.defaultServiceConfigRawJSON != nil &#123;</span><br><span class="line">		scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON)</span><br><span class="line">		if scpr.Err != nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;%s: %v&quot;, invalidDefaultServiceConfigErrPrefix, scpr.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		// 设置默认服务配置</span><br><span class="line">		cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig)</span><br><span class="line">	&#125;</span><br><span class="line">	//keepalive相关配置</span><br><span class="line">	cc.mkp = cc.dopts.copts.KeepaliveParams</span><br><span class="line"></span><br><span class="line">//如果没设置拨号函数，则使用默认的拨号函数，如果有设置代理的话，这个函数会根据系统环境变量(HTTP_PROXY或者HTTPS_PROXY)的代理设置来进行网络连接</span><br><span class="line">	if cc.dopts.copts.Dialer == nil &#123;</span><br><span class="line">		cc.dopts.copts.Dialer = newProxyDialer(</span><br><span class="line">			func(ctx context.Context, addr string) (net.Conn, error) &#123;</span><br><span class="line">				network, addr := parseDialTarget(addr)</span><br><span class="line">				return (&amp;net.Dialer&#123;&#125;).DialContext(ctx, network, addr)</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">    //UserAgent添加“grpcUA”</span><br><span class="line">	if cc.dopts.copts.UserAgent != &quot;&quot; &#123;</span><br><span class="line">		cc.dopts.copts.UserAgent += &quot; &quot; + grpcUA</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cc.dopts.copts.UserAgent = grpcUA</span><br><span class="line">	&#125;</span><br><span class="line">    // 如果设置了超时</span><br><span class="line">	if cc.dopts.timeout &gt; 0 &#123;</span><br><span class="line">		var cancel context.CancelFunc</span><br><span class="line">		ctx, cancel = context.WithTimeout(ctx, cc.dopts.timeout)</span><br><span class="line">		defer cancel()</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			conn, err = nil, ctx.Err()</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	scSet := false</span><br><span class="line">	// 如果提供了scChan，支持对serviceConfig进行热更</span><br><span class="line">	if cc.dopts.scChan != nil &#123;</span><br><span class="line">		// Try to get an initial service config.</span><br><span class="line">		select &#123;</span><br><span class="line">		case sc, ok := &lt;-cc.dopts.scChan:</span><br><span class="line">			if ok &#123;</span><br><span class="line">				cc.sc = &amp;sc</span><br><span class="line">				scSet = true// 成功获取初始的serviceConfig</span><br><span class="line">			&#125;</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 提供retry时的退避算法</span><br><span class="line">	if cc.dopts.bs == nil &#123;</span><br><span class="line">		cc.dopts.bs = backoff.DefaultExponential</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // resolverBuilder，用于解析target为目标服务列表</span><br><span class="line">	// Determine the resolver to use.</span><br><span class="line">	cc.parsedTarget = grpcutil.ParseTarget(cc.target)</span><br><span class="line">	channelz.Infof(cc.channelzID, &quot;parsed scheme: %q&quot;, cc.parsedTarget.Scheme)</span><br><span class="line">	resolverBuilder := cc.getResolver(cc.parsedTarget.Scheme)</span><br><span class="line">	if resolverBuilder == nil &#123;</span><br><span class="line">		// If resolver builder is still nil, the parsed target&apos;s scheme is</span><br><span class="line">		// not registered. Fallback to default resolver and set Endpoint to</span><br><span class="line">		// the original target.</span><br><span class="line">		channelz.Infof(cc.channelzID, &quot;scheme %q not registered, fallback to default scheme&quot;, cc.parsedTarget.Scheme)</span><br><span class="line">		cc.parsedTarget = resolver.Target&#123;</span><br><span class="line">			Scheme:   resolver.GetDefaultScheme(),</span><br><span class="line">			Endpoint: target,</span><br><span class="line">		&#125;</span><br><span class="line">		resolverBuilder = cc.getResolver(cc.parsedTarget.Scheme)</span><br><span class="line">		if resolverBuilder == nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;could not get resolver for default scheme: %q&quot;, cc.parsedTarget.Scheme)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    //连接证书</span><br><span class="line">	creds := cc.dopts.copts.TransportCredentials</span><br><span class="line">	if creds != nil &amp;&amp; creds.Info().ServerName != &quot;&quot; &#123;</span><br><span class="line">		cc.authority = creds.Info().ServerName</span><br><span class="line">	&#125; else if cc.dopts.insecure &amp;&amp; cc.dopts.authority != &quot;&quot; &#123;</span><br><span class="line">		cc.authority = cc.dopts.authority</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// Use endpoint from &quot;scheme://authority/endpoint&quot; as the default</span><br><span class="line">		// authority for ClientConn.</span><br><span class="line">		cc.authority = cc.parsedTarget.Endpoint</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果提供了scChan但是还没有获取到初始的serviceConfig，则阻塞等待serviceConfig</span><br><span class="line">	if cc.dopts.scChan != nil &amp;&amp; !scSet &#123;</span><br><span class="line">		// Blocking wait for the initial service config.</span><br><span class="line">		select &#123;</span><br><span class="line">		case sc, ok := &lt;-cc.dopts.scChan:</span><br><span class="line">			if ok &#123;</span><br><span class="line">				cc.sc = &amp;sc</span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			return nil, ctx.Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 启动子协程，监听scChan，进行serviceConfig的热更</span><br><span class="line">	if cc.dopts.scChan != nil &#123;</span><br><span class="line">		go cc.scWatcher()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var credsClone credentials.TransportCredentials</span><br><span class="line">	if creds := cc.dopts.copts.TransportCredentials; creds != nil &#123;</span><br><span class="line">		credsClone = creds.Clone()</span><br><span class="line">	&#125;</span><br><span class="line">	cc.balancerBuildOpts = balancer.BuildOptions&#123;</span><br><span class="line">		DialCreds:        credsClone,</span><br><span class="line">		CredsBundle:      cc.dopts.copts.CredsBundle,</span><br><span class="line">		Dialer:           cc.dopts.copts.Dialer,</span><br><span class="line">		ChannelzParentID: cc.channelzID,</span><br><span class="line">		Target:           cc.parsedTarget,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Build the resolver.</span><br><span class="line">	rWrapper, err := newCCResolverWrapper(cc, resolverBuilder)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to build resolver: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	cc.mu.Lock()</span><br><span class="line">	cc.resolverWrapper = rWrapper</span><br><span class="line">	cc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	// A blocking dial blocks until the clientConn is ready.</span><br><span class="line">	// 默认Dial不会等待网络连接完成，如果指定了blcok，则会阻塞等待网络连接完成才返回</span><br><span class="line">	if cc.dopts.block &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			s := cc.GetState()</span><br><span class="line">			if s == connectivity.Ready &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125; else if cc.dopts.copts.FailOnNonTempDialError &amp;&amp; s == connectivity.TransientFailure &#123;</span><br><span class="line">				if err = cc.blockingpicker.connectionError(); err != nil &#123;</span><br><span class="line">					terr, ok := err.(interface &#123;</span><br><span class="line">						Temporary() bool</span><br><span class="line">					&#125;)</span><br><span class="line">					if ok &amp;&amp; !terr.Temporary() &#123;</span><br><span class="line">						return nil, err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if !cc.WaitForStateChange(ctx, s) &#123;</span><br><span class="line">				// ctx got timeout or canceled.</span><br><span class="line">				return nil, ctx.Err()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return cc, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，从以上代码可以看出，调用Dial函数实际上是调用了DialContext函数，而DialContext主要是对 ConnectCoon结构体、 dialOptions结构体（cc.dopts）及ConnectOptions结构体（cc.dopts.copts）做初始化操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/RPC概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/RPC概述/" itemprop="url">RPC-个人碎碎念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T23:34:53+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RPC(Remote Procedure Call)，通常翻译为远程过程调用，但我觉得翻译成远程程序调用比较方便理解。调用的程序在不同的内存空间,通过网络调用，而不需要了解底层的网络协议（函数调用网络化），它假定了某些传输协议的存在，以便为通信程序建携带信息数据。</p>
<p>RPC也是经典的C/S模式，传送请求，接收回应</p>
<p>RPC调用的流程：</p>
<ol>
<li>客户端调用client stub,本地调用，将参数push进栈</li>
<li>clinet stub 将参数打包成一个消息，然后发送这个消息。打包过程叫 marshaling</li>
<li>client所在的系统将消息发送给server</li>
<li>server系统将收到的包传给server stub</li>
<li>server stub 解包得到参数，解包过程叫unmarshaling</li>
<li>最后server stub调用服务程序，返回结果按照相反的步骤传给client</li>
</ol>
<h4 id="与RESTful的对比"><a href="#与RESTful的对比" class="headerlink" title="与RESTful的对比"></a>与RESTful的对比</h4><p>传输协议：</p>
<ul>
<li>RPC可基于TPC、UDP或HTTP</li>
<li>RESTful基于HTTP</li>
</ul>
<p>操作对象</p>
<ul>
<li>RPC操作的是对象与方法</li>
<li>RESTful操作的是资源</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>client与服务端的点对点调用</p>
<ul>
<li>stub</li>
<li>通信</li>
<li>RPC消息序列化</li>
</ul>
<p>服务治理</p>
<ul>
<li>服务发现与注销</li>
<li>服务高可用</li>
<li>负载均衡</li>
</ul>
<p>从RPC的功能延伸出来，可以比较下当前的RPC框架，发现这些RPC框架主要有两个方向</p>
<ol>
<li>偏向于跨语言调用方面</li>
</ol>
<ul>
<li>gRPC</li>
<li>thrift（不支持服务治理）</li>
<li>rpcx</li>
</ul>
<ol start="2">
<li>偏向于服务治理方面</li>
</ol>
<ul>
<li>Alibab Dubbo</li>
<li>Motan </li>
</ul>
<p>使用RPC，体会很深的的两个特性：</p>
<ol>
<li>屏蔽了本地调用与远程调用的区别，我们调用别的机器上的程序方法就像调用本地方法一样。</li>
<li>屏蔽了网络通讯的复杂性，我们不用去处理复杂的网络编程相关的东西，能更专注于处理业务逻辑。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/HTTP Hijack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/25/HTTP Hijack/" itemprop="url">HTTP hijack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T11:14:44+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在学习标准库net/rpc时，看rpc基于HTTP的那段内容，发现了一个有趣的地方。</p>
<p>RPC OVER HTTP，只是使用HTTP协议来建立连接，连接建立后，就没HTTP啥事了。这里有个术语叫hijack(劫持)。</p>
<p>RPC OVER HTTP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    </span><br><span class="line">    // new 一个 Arith 对象</span><br><span class="line">    arith := new(Arith)</span><br><span class="line">    // 将 arith 对象注册进rpc default 服务</span><br><span class="line">    rpc.Register(arith)</span><br><span class="line">    // 将rpc服务注册到HTTP协议上</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">    // http 负责监听端口</span><br><span class="line">    err := http.ListenAndServe(&quot;:1234&quot;, nil)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">---&gt;</span><br><span class="line">里面其实也是将rpc server 作为实现了 http.Handler 接口的 handler（负责处理请求），传递给http包下的缺省 servermux 路由管理器</span><br></pre></td></tr></table></figure>
<p>RPC server 实现了 http.Handler 接口，也就是有ServerHTTP方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    // ServeHTTP implements an http.Handler that answers RPC requests.</span><br><span class="line">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	if req.Method != &quot;CONNECT&quot; &#123;</span><br><span class="line">		w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		io.WriteString(w, &quot;405 must CONNECT\n&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	conn, _, err := w.(http.Hijacker).Hijack()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Print(&quot;rpc hijacking &quot;, req.RemoteAddr, &quot;: &quot;, err.Error())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	io.WriteString(conn, &quot;HTTP/1.0 &quot;+connected+&quot;\n\n&quot;)</span><br><span class="line">	server.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ServerHTTP 处理了HTTP请求的业务逻辑，它首先处理HTTP的CONNECT请求，接收后就Hijack这个请求，然后将请求conn 扔给 ServerConn去处理。可以看出，net/rpc 只是利用 HTTP CONNECT 建立连接，这与普通的RESTful api 还是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Hijacker interface &#123;</span><br><span class="line">	// Hijack lets the caller take over the connection.</span><br><span class="line">	// After a call to Hijack the HTTP server library</span><br><span class="line">	// will not do anything else with the connection.</span><br><span class="line">	//</span><br><span class="line">	// It becomes the caller&apos;s responsibility to manage</span><br><span class="line">	// and close the connection.</span><br><span class="line">	//</span><br><span class="line">	// The returned net.Conn may have read or write deadlines</span><br><span class="line">	// already set, depending on the configuration of the</span><br><span class="line">	// Server. It is the caller&apos;s responsibility to set</span><br><span class="line">	// or clear those deadlines as needed.</span><br><span class="line">	//</span><br><span class="line">	// The returned bufio.Reader may contain unprocessed buffered</span><br><span class="line">	// data from the client.</span><br><span class="line">	//</span><br><span class="line">	// After a call to Hijack, the original Request.Body must not</span><br><span class="line">	// be used. The original Request&apos;s Context remains valid and</span><br><span class="line">	// is not canceled until the Request&apos;s ServeHTTP method</span><br><span class="line">	// returns.</span><br><span class="line">	Hijack() (net.Conn, *bufio.ReadWriter, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Hijack()方法，会将HTTP对应的TCP链接取出来，取出来之后，HTTP 服务就不在管这个链接了，需要由调用方去管理了。</p>
<p>使用了Hijack之后，http的响应有什么不同呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, handler2)</span><br><span class="line">	_ = http.ListenAndServe(&quot;:8008&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handler1(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">	hijacker,_ := writer.(http.Hijacker)</span><br><span class="line">	conn, buf, _ := hijacker.Hijack()</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	_, _ = buf.WriteString(&quot;hello world&quot;)</span><br><span class="line">	_ = buf.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handler2(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">	_, _ = fmt.Fprint(writer, &quot;hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handler1的响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i &quot;http://localhost:8008/&quot;</span><br><span class="line">hello world%</span><br></pre></td></tr></table></figure></p>
<p>handler2的响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -i &quot;http://localhost:8008/&quot;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 24 Apr 2020 15:43:26 GMT</span><br><span class="line">Content-Length: 11</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">hello world%</span><br></pre></td></tr></table></figure></p>
<p>可以看出， Hijack 后 response header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *conn) serve(ctx context.Context) &#123;</span><br><span class="line">    ...</span><br><span class="line">    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    w.cancelCtx()</span><br><span class="line">    if c.hijacked() &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    w.finishRequest()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是net/http包中的方法，也是http路由的核心方法。调用ServeHTTP（也就是上边的handle方法）方法，如果被hijack了就直接return了，而一般的http请求会经过后边的finishRequest方法，加入headers等并关闭连接。</p>
<p>在Go中，Hijack方法的使用场景有两种</p>
<ol>
<li>基于HTTP的RPC</li>
<li>从HTTP协议升级到WebSocket</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/Linux下开机自启动顺序之坑小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/Linux下开机自启动顺序之坑小记/" itemprop="url">Linux下开机自启动顺序之坑小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T10:27:40+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景介绍：工控机上有个使用 superviosr 守护的程序（下称之为ck），ck 的启动依赖于 MySQL。superviosr 与 MySQL 都加入了开机自启动豪华套餐。</p>
<p>问题描述：一线实施人员发现某个试点项目案场的 ck 程序未能正常运行，研发排查发现是因为案场曾停过电，工控机重新启动时，ck 程序先于 MySQL 启动了。而 ck   程序的自动重启次数设置的太低（重启次数用完了 MySQL 仍未完全启动完成），导致未能正常运行。</p>
<p>解决方案：在 supervisor 的自启动设置上，加上后于 MySQL 启动的规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /lib/systemd/system</span><br><span class="line">$ sudo vim sudo vim supervisor.service</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在After 附加上 mysql.service,以空格分隔</span><br><span class="line">[Uint]</span><br><span class="line">After=network.target mysql.service</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/18/macOS下golang 交叉编译失败小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/macOS下golang 交叉编译失败小记/" itemprop="url">macOS下golang 交叉编译失败小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T18:55:21+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段时间在AIOT小组支援，需要做一个在工控机（ubuntu系统）上运行的HTTP服务，用Golang实现，使用sqlite3作为存储。</p>
<p>在 macOS 上编译 Linux 可执行文件时，遇到了一些坑，这里做下记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o ./httpServer ./</span><br></pre></td></tr></table></figure>
<p>编译没有任何问题，可真正到工控机上运行的时候，报了 go-sqlite3 包未 import 的问题。</p>
<blockquote>
<p>models setup fail err:sql: unknown driver “sqlite3” (forgotten import?)</p>
</blockquote>
<p>查了一下，<br>go-sqlite3 is cgo module. so you need to install cross C compiler.<br>大意是go-sqlite包使用了CGO module，所以编译时要开启CGO_ENABLED，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=1</span><br></pre></td></tr></table></figure></p>
<p>还需要安装C交叉编译器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install FiloSottile/musl-cross/musl-cross</span><br></pre></td></tr></table></figure></p>
<p>这个安装耗时比较久，大概要40分钟（我的本子风扇会呼啦啦转，发热严重），但请耐心等待安装完成。</p>
<p>然后使用下面的命令就可以编译成功了！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=x86_64-linux-musl-gcc CXX=x86_64-linux-musl-g++ GOARCH=amd64 GOOS=linux CGO_ENABLED=1 go build -ldflags &quot;-linkmode external -extldflags -static&quot; -o ./httpServer ./</span><br></pre></td></tr></table></figure></p>
<p>参考:</p>
<ol>
<li><a href="https://github.com/mattn/go-sqlite3/issues/384" target="_blank" rel="noopener">Github上go-sqlite3相关issue</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/Golang中的Unicode、UTF-8与字节序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BansheeLW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厦门鱼肝油厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/Golang中的Unicode、UTF-8与字节序列/" itemprop="url">Golang中的Unicode、UTF-8与字节序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T17:27:49+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在对Go语言的字符串进行操作时，都会遇到 unicode、UTF-8和字节序列这几个词，一直对这几个名称之间的关系一知半解。今次，我们就来理清这里的关系。</p>
<p>Unicode定义了一个字符与一个编码的映射，但是，对应的存储却没有制定。就拿一个大写字符A来说，对应编码是0x0041，但因此存储规则没有制定，那么，如果我们用4个字节来存储，就是0x00000041。这种规定了用几个字节来存储的方式，就可以说是Unicode编码规范的具体实现。比如，UTF-8（最少用一个字节就能表示一个字符的编码实现，最多使用四个字节）和UTF-16(最少用两个字节能表示一个字符的编码实现)。</p>
<p>Go语言中的string类型值由若干个Unicode字符（也叫Unicode码点）组成，每个Unicode字符都可以由一个rune类型的值来承载。这些字符在底层都会转换为UTF-8编码值，而UTF-8编码值又会以字节序列的形式来表达和存储，因此，一个string类型的值在底层就是一个能够表达若干个UTF-8编码值的字节序列。</p>
<p>我们常使用for …range 语句对string进行遍历，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	str := &quot;UTF 码点 &quot;</span><br><span class="line">	for i, c := range str &#123;</span><br><span class="line">		fmt.Printf(&quot;%d: %q [% x]\n&quot;, i, c, []byte(string(c)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">索引 Unicode码点 字节序列（字符存储使用的是UTF-8编码，至少使用一个字节，最多四个字节，英文一个字节，中文三个字节）</span><br><span class="line">0: &apos;U&apos; [55]</span><br><span class="line">1: &apos;T&apos; [54]</span><br><span class="line">2: &apos;F&apos; [46]</span><br><span class="line">3: &apos; &apos; [20]</span><br><span class="line">4: &apos;码&apos; [e7 a0 81]</span><br><span class="line">7: &apos;点&apos; [e7 82 b9]</span><br><span class="line">10: &apos; &apos; [20]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>这段代码，可以看出，for语句逐一迭代的是字符串里的每个Unicode字符，字符串的底层实现是字节序列，使用UTF-8编码，根据Unicode字符的不同而选择不同的字节长度来存储这个字符。所以说，迭代的时候，就是在字节序列里，去迭代每一个UTF-8编码值，也就是每一个Unicode字符。</p>
<p>总结：字符串string就是一个个Unicode字符组成的，底层使用UTF-8编码格式来存储Unicode字符（UTF-8编码方案是Unicode编码规范的一种具体实现，使用至少一个字节来存储Unicode字符，最多四个字节）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="BansheeLW" />
            
              <p class="site-author-name" itemprop="name">BansheeLW</p>
              <p class="site-description motion-element" itemprop="description">太阳落山了，我是你的渔船，你的锚</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BansheeLW</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
